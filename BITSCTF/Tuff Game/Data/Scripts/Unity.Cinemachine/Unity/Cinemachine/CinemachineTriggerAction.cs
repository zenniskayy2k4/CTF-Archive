using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Playables;
using UnityEngine.Serialization;

namespace Unity.Cinemachine
{
	[SaveDuringPlay]
	[AddComponentMenu("Cinemachine/Helpers/Cinemachine Trigger Action")]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@3.1/manual/CinemachineTriggerAction.html")]
	public class CinemachineTriggerAction : MonoBehaviour
	{
		[Serializable]
		public struct ActionSettings
		{
			public enum ActionModes
			{
				EventOnly = 0,
				PriorityBoost = 1,
				Activate = 2,
				Deactivate = 3,
				Enable = 4,
				Disable = 5,
				Play = 6,
				Stop = 7
			}

			[Serializable]
			public class TriggerEvent : UnityEvent
			{
			}

			public enum TimeModes
			{
				FromStart = 0,
				FromEnd = 1,
				BeforeNow = 2,
				AfterNow = 3
			}

			[Tooltip("What action to take")]
			[FormerlySerializedAs("m_Action")]
			public ActionModes Action;

			[Tooltip("The target object on which to operate.  If null, then the current behaviour/GameObject will be used")]
			[FormerlySerializedAs("m_Target")]
			public UnityEngine.Object Target;

			[Tooltip("If PriorityBoost, this amount will be added to the virtual camera's priority")]
			[FormerlySerializedAs("m_BoostAmount")]
			public int BoostAmount;

			[Tooltip("If playing a timeline, start at this time")]
			[FormerlySerializedAs("m_StartTime")]
			public float StartTime;

			[Tooltip("How to interpret the start time")]
			[FormerlySerializedAs("m_Mode")]
			public TimeModes Mode;

			[Tooltip("This event will be invoked")]
			[FormerlySerializedAs("m_Event")]
			public TriggerEvent Event;

			public ActionSettings(ActionModes action)
			{
				Action = action;
				Target = null;
				BoostAmount = 0;
				StartTime = 0f;
				Mode = TimeModes.FromStart;
				Event = new TriggerEvent();
			}

			public void Invoke()
			{
				UnityEngine.Object target = Target;
				if (target != null)
				{
					GameObject gameObject = target as GameObject;
					Behaviour behaviour = target as Behaviour;
					if (behaviour != null)
					{
						gameObject = behaviour.gameObject;
					}
					switch (Action)
					{
					case ActionModes.PriorityBoost:
					{
						if (gameObject.TryGetComponent<CinemachineVirtualCameraBase>(out var component5))
						{
							component5.Priority.Value += BoostAmount;
							component5.Prioritize();
						}
						break;
					}
					case ActionModes.Activate:
						if (gameObject != null)
						{
							gameObject.SetActive(value: true);
							if (gameObject.TryGetComponent<CinemachineVirtualCameraBase>(out var component6))
							{
								component6.Prioritize();
							}
						}
						break;
					case ActionModes.Deactivate:
						if (gameObject != null)
						{
							gameObject.SetActive(value: false);
						}
						break;
					case ActionModes.Enable:
						if (behaviour != null)
						{
							behaviour.enabled = true;
						}
						break;
					case ActionModes.Disable:
						if (behaviour != null)
						{
							behaviour.enabled = false;
						}
						break;
					case ActionModes.Play:
					{
						Animation component4;
						if (gameObject.TryGetComponent<PlayableDirector>(out var component3))
						{
							double num = 0.0;
							double duration = component3.duration;
							double time = component3.time;
							num = Mode switch
							{
								TimeModes.FromEnd => duration - (double)StartTime, 
								TimeModes.BeforeNow => time - (double)StartTime, 
								TimeModes.AfterNow => time + (double)StartTime, 
								_ => num + (double)StartTime, 
							};
							component3.time = num;
							component3.Play();
						}
						else if (gameObject.TryGetComponent<Animation>(out component4))
						{
							component4.Play();
						}
						break;
					}
					case ActionModes.Stop:
					{
						Animation component2;
						if (gameObject.TryGetComponent<PlayableDirector>(out var component))
						{
							component.Stop();
						}
						else if (gameObject.TryGetComponent<Animation>(out component2))
						{
							component2.Stop();
						}
						break;
					}
					}
				}
				Event.Invoke();
			}
		}

		[Header("Trigger Object Filter")]
		[Tooltip("Only triggers generated by objects on these layers will be considered")]
		[FormerlySerializedAs("m_LayerMask")]
		public LayerMask LayerMask = 1;

		[TagField]
		[Tooltip("If set, only triggers generated by objects with this tag will be considered")]
		[FormerlySerializedAs("m_WithTag")]
		public string WithTag = string.Empty;

		[TagField]
		[Tooltip("Triggers generated by objects with this tag will be ignored")]
		[FormerlySerializedAs("m_WithoutTag")]
		public string WithoutTag = string.Empty;

		[NoSaveDuringPlay]
		[Tooltip("Skip this many trigger entries before taking action")]
		[FormerlySerializedAs("m_SkipFirst")]
		public int SkipFirst;

		[Tooltip("Repeat the action for all subsequent trigger entries")]
		[FormerlySerializedAs("m_Repeating")]
		public bool Repeating = true;

		[Tooltip("What action to take when an eligible object enters the collider or trigger zone")]
		[FormerlySerializedAs("m_OnObjectEnter")]
		public ActionSettings OnObjectEnter = new ActionSettings(ActionSettings.ActionModes.EventOnly);

		[Tooltip("What action to take when an eligible object exits the collider or trigger zone")]
		[FormerlySerializedAs("m_OnObjectExit")]
		public ActionSettings OnObjectExit = new ActionSettings(ActionSettings.ActionModes.EventOnly);

		private HashSet<GameObject> m_ActiveTriggerObjects = new HashSet<GameObject>();

		private bool Filter(GameObject other)
		{
			if (!base.enabled)
			{
				return false;
			}
			if (((1 << other.layer) & (int)LayerMask) == 0)
			{
				return false;
			}
			if (WithTag.Length != 0 && !other.CompareTag(WithTag))
			{
				return false;
			}
			if (WithoutTag.Length != 0 && other.CompareTag(WithoutTag))
			{
				return false;
			}
			return true;
		}

		private void InternalDoTriggerEnter(GameObject other)
		{
			if (Filter(other))
			{
				SkipFirst--;
				if (SkipFirst <= -1 && (Repeating || SkipFirst == -1))
				{
					m_ActiveTriggerObjects.Add(other);
					OnObjectEnter.Invoke();
				}
			}
		}

		private void InternalDoTriggerExit(GameObject other)
		{
			if (m_ActiveTriggerObjects.Contains(other))
			{
				m_ActiveTriggerObjects.Remove(other);
				if (base.enabled)
				{
					OnObjectExit.Invoke();
				}
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnTriggerExit(Collider other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnCollisionEnter(Collision other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnCollisionExit(Collision other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnTriggerEnter2D(Collider2D other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnTriggerExit2D(Collider2D other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnCollisionEnter2D(Collision2D other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnCollisionExit2D(Collision2D other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnEnable()
		{
		}
	}
}
