using System.CodeDom;
using System.Collections.Specialized;
using System.Xml.Schema;

namespace System.Xml.Serialization.Advanced
{
	internal class MappedTypeDesc
	{
		private string name;

		private string ns;

		private XmlSchemaType xsdType;

		private XmlSchemaObject context;

		private string clrType;

		private SchemaImporterExtension extension;

		private CodeNamespace code;

		private bool exported;

		private StringCollection references;

		internal SchemaImporterExtension Extension => extension;

		internal string Name => clrType;

		internal StringCollection ReferencedAssemblies
		{
			get
			{
				if (references == null)
				{
					references = new StringCollection();
				}
				return references;
			}
		}

		internal MappedTypeDesc(string clrType, string name, string ns, XmlSchemaType xsdType, XmlSchemaObject context, SchemaImporterExtension extension, CodeNamespace code, StringCollection references)
		{
			this.clrType = clrType.Replace('+', '.');
			this.name = name;
			this.ns = ns;
			this.xsdType = xsdType;
			this.context = context;
			this.code = code;
			this.references = references;
			this.extension = extension;
		}

		internal CodeTypeDeclaration ExportTypeDefinition(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit)
		{
			if (exported)
			{
				return null;
			}
			exported = true;
			foreach (CodeNamespaceImport import in code.Imports)
			{
				codeNamespace.Imports.Add(import);
			}
			CodeTypeDeclaration codeTypeDeclaration = null;
			string text = Res.GetString("This type definition was generated by {0} schema importer extension.", extension.GetType().FullName);
			foreach (CodeTypeDeclaration type in code.Types)
			{
				if (clrType == type.Name)
				{
					if (codeTypeDeclaration != null)
					{
						throw new InvalidOperationException(Res.GetString("Schema importer extension {0} generated duplicate type definitions: {1}.", extension.GetType().FullName, clrType));
					}
					codeTypeDeclaration = type;
				}
				type.Comments.Add(new CodeCommentStatement(text, docComment: false));
				codeNamespace.Types.Add(type);
			}
			if (codeCompileUnit != null)
			{
				StringEnumerator enumerator2 = ReferencedAssemblies.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						string current = enumerator2.Current;
						if (!codeCompileUnit.ReferencedAssemblies.Contains(current))
						{
							codeCompileUnit.ReferencedAssemblies.Add(current);
						}
					}
				}
				finally
				{
					if (enumerator2 is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
			}
			return codeTypeDeclaration;
		}
	}
}
