namespace System.Text.RegularExpressions
{
	/// <summary>The <see cref="T:System.Text.RegularExpressions.RegexRunner" /> class is the base class for compiled regular expressions.</summary>
	public abstract class RegexRunner
	{
		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runtextbeg;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runtextend;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runtextstart;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal string runtext;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runtextpos;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int[] runtrack;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runtrackpos;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int[] runstack;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runstackpos;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int[] runcrawl;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runcrawlpos;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal int runtrackcount;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal Match runmatch;

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected internal Regex runregex;

		private int _timeout;

		private bool _ignoreTimeout;

		private int _timeoutOccursAt;

		private const int TimeoutCheckFrequency = 1000;

		private int _timeoutChecksToSkip;

		/// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.RegexRunner" /> class.</summary>
		protected internal RegexRunner()
		{
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="regex">An instance of the regular expression engine.</param>
		/// <param name="text">The text to scan for a pattern match.</param>
		/// <param name="textbeg">The zero-based starting position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
		/// <param name="textend">The zero-based ending position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
		/// <param name="textstart">The zero-based starting position to scan for this match.</param>
		/// <param name="prevlen">The number of characters in the previous match.</param>
		/// <param name="quick">
		///   <see langword="true" /> to search for a match in quick mode; otherwise, <see langword="false" />.</param>
		/// <returns>A match.</returns>
		protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick)
		{
			return Scan(regex, text, textbeg, textend, textstart, prevlen, quick, regex.MatchTimeout);
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="regex">An instance of the regular expression engine.</param>
		/// <param name="text">The text to scan for a pattern match.</param>
		/// <param name="textbeg">The zero-based starting position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
		/// <param name="textend">The zero-based ending position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
		/// <param name="textstart">The zero-based starting position to scan for this match.</param>
		/// <param name="prevlen">The number of characters in the previous match.</param>
		/// <param name="quick">
		///   <see langword="true" /> to search for a match in quick mode; otherwise, <see langword="false" />.</param>
		/// <param name="timeout">The timeout interval.</param>
		/// <returns>A match.</returns>
		protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout)
		{
			bool flag = false;
			Regex.ValidateMatchTimeout(timeout);
			_ignoreTimeout = Regex.InfiniteMatchTimeout == timeout;
			_timeout = (_ignoreTimeout ? ((int)Regex.InfiniteMatchTimeout.TotalMilliseconds) : ((int)(timeout.TotalMilliseconds + 0.5)));
			runregex = regex;
			runtext = text;
			runtextbeg = textbeg;
			runtextend = textend;
			runtextstart = textstart;
			int num = ((!runregex.RightToLeft) ? 1 : (-1));
			int num2 = (runregex.RightToLeft ? runtextbeg : runtextend);
			runtextpos = textstart;
			if (prevlen == 0)
			{
				if (runtextpos == num2)
				{
					return Match.Empty;
				}
				runtextpos += num;
			}
			StartTimeoutWatch();
			while (true)
			{
				if (FindFirstChar())
				{
					CheckTimeout();
					if (!flag)
					{
						InitMatch();
						flag = true;
					}
					Go();
					if (runmatch._matchcount[0] > 0)
					{
						return TidyMatch(quick);
					}
					runtrackpos = runtrack.Length;
					runstackpos = runstack.Length;
					runcrawlpos = runcrawl.Length;
				}
				if (runtextpos == num2)
				{
					break;
				}
				runtextpos += num;
			}
			TidyMatch(quick: true);
			return Match.Empty;
		}

		private void StartTimeoutWatch()
		{
			if (!_ignoreTimeout)
			{
				_timeoutChecksToSkip = 1000;
				_timeoutOccursAt = Environment.TickCount + _timeout;
			}
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected void CheckTimeout()
		{
			if (!_ignoreTimeout)
			{
				DoCheckTimeout();
			}
		}

		private void DoCheckTimeout()
		{
			if (--_timeoutChecksToSkip == 0)
			{
				_timeoutChecksToSkip = 1000;
				int tickCount = Environment.TickCount;
				if (tickCount >= _timeoutOccursAt && (0 <= _timeoutOccursAt || 0 >= tickCount))
				{
					throw new RegexMatchTimeoutException(runtext, runregex.pattern, TimeSpan.FromMilliseconds(_timeout));
				}
			}
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected abstract void Go();

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <returns>Returns <see cref="T:System.Boolean" />.</returns>
		protected abstract bool FindFirstChar();

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected abstract void InitTrackCount();

		private void InitMatch()
		{
			if (runmatch == null)
			{
				if (runregex.caps != null)
				{
					runmatch = new MatchSparse(runregex, runregex.caps, runregex.capsize, runtext, runtextbeg, runtextend - runtextbeg, runtextstart);
				}
				else
				{
					runmatch = new Match(runregex, runregex.capsize, runtext, runtextbeg, runtextend - runtextbeg, runtextstart);
				}
			}
			else
			{
				runmatch.Reset(runregex, runtext, runtextbeg, runtextend, runtextstart);
			}
			if (runcrawl != null)
			{
				runtrackpos = runtrack.Length;
				runstackpos = runstack.Length;
				runcrawlpos = runcrawl.Length;
				return;
			}
			InitTrackCount();
			int num = runtrackcount * 8;
			int num2 = runtrackcount * 8;
			if (num < 32)
			{
				num = 32;
			}
			if (num2 < 16)
			{
				num2 = 16;
			}
			runtrack = new int[num];
			runtrackpos = num;
			runstack = new int[num2];
			runstackpos = num2;
			runcrawl = new int[32];
			runcrawlpos = 32;
		}

		private Match TidyMatch(bool quick)
		{
			if (!quick)
			{
				Match match = runmatch;
				runmatch = null;
				match.Tidy(runtextpos);
				return match;
			}
			return null;
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected void EnsureStorage()
		{
			if (runstackpos < runtrackcount * 4)
			{
				DoubleStack();
			}
			if (runtrackpos < runtrackcount * 4)
			{
				DoubleTrack();
			}
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="index">The possible boundary position.</param>
		/// <param name="startpos">The starting position.</param>
		/// <param name="endpos">The ending position.</param>
		/// <returns>Returns <see cref="T:System.Boolean" />.</returns>
		protected bool IsBoundary(int index, int startpos, int endpos)
		{
			return (index > startpos && RegexCharClass.IsWordChar(runtext[index - 1])) != (index < endpos && RegexCharClass.IsWordChar(runtext[index]));
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="index">The possible ECMA boundary position.</param>
		/// <param name="startpos">The starting position.</param>
		/// <param name="endpos">The ending position.</param>
		/// <returns>Returns <see cref="T:System.Boolean" />.</returns>
		protected bool IsECMABoundary(int index, int startpos, int endpos)
		{
			return (index > startpos && RegexCharClass.IsECMAWordChar(runtext[index - 1])) != (index < endpos && RegexCharClass.IsECMAWordChar(runtext[index]));
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="ch">A character.</param>
		/// <param name="set">The character set.</param>
		/// <param name="category">The character category.</param>
		/// <returns>Returns <see cref="T:System.Boolean" />.</returns>
		protected static bool CharInSet(char ch, string set, string category)
		{
			string set2 = RegexCharClass.ConvertOldStringsToClass(set, category);
			return RegexCharClass.CharInClass(ch, set2);
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. Determines whether a character is in a character class.</summary>
		/// <param name="ch">A character to test.</param>
		/// <param name="charClass">The internal name of a character class.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="ch" /> parameter is in the character class specified by the <paramref name="charClass" /> parameter.</returns>
		protected static bool CharInClass(char ch, string charClass)
		{
			return RegexCharClass.CharInClass(ch, charClass);
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected void DoubleTrack()
		{
			int[] destinationArray = new int[runtrack.Length * 2];
			Array.Copy(runtrack, 0, destinationArray, runtrack.Length, runtrack.Length);
			runtrackpos += runtrack.Length;
			runtrack = destinationArray;
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected void DoubleStack()
		{
			int[] destinationArray = new int[runstack.Length * 2];
			Array.Copy(runstack, 0, destinationArray, runstack.Length, runstack.Length);
			runstackpos += runstack.Length;
			runstack = destinationArray;
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected void DoubleCrawl()
		{
			int[] destinationArray = new int[runcrawl.Length * 2];
			Array.Copy(runcrawl, 0, destinationArray, runcrawl.Length, runcrawl.Length);
			runcrawlpos += runcrawl.Length;
			runcrawl = destinationArray;
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="i">A number to save.</param>
		protected void Crawl(int i)
		{
			if (runcrawlpos == 0)
			{
				DoubleCrawl();
			}
			runcrawl[--runcrawlpos] = i;
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <returns>Returns <see cref="T:System.Int32" />.</returns>
		protected int Popcrawl()
		{
			return runcrawl[runcrawlpos++];
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <returns>Returns <see cref="T:System.Int32" />.</returns>
		protected int Crawlpos()
		{
			return runcrawl.Length - runcrawlpos;
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="capnum">A capture number.</param>
		/// <param name="start">The starting position of the capture.</param>
		/// <param name="end">The ending position of the capture.</param>
		protected void Capture(int capnum, int start, int end)
		{
			if (end < start)
			{
				int num = end;
				end = start;
				start = num;
			}
			Crawl(capnum);
			runmatch.AddMatch(capnum, start, end - start);
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="capnum">A capture number.</param>
		/// <param name="uncapnum">A saved capture number.</param>
		/// <param name="start">The starting position.</param>
		/// <param name="end">The ending position.</param>
		protected void TransferCapture(int capnum, int uncapnum, int start, int end)
		{
			if (end < start)
			{
				int num = end;
				end = start;
				start = num;
			}
			int num2 = MatchIndex(uncapnum);
			int num3 = num2 + MatchLength(uncapnum);
			if (start >= num3)
			{
				end = start;
				start = num3;
			}
			else if (end <= num2)
			{
				start = num2;
			}
			else
			{
				if (end > num3)
				{
					end = num3;
				}
				if (num2 > start)
				{
					start = num2;
				}
			}
			Crawl(uncapnum);
			runmatch.BalanceMatch(uncapnum);
			if (capnum != -1)
			{
				Crawl(capnum);
				runmatch.AddMatch(capnum, start, end - start);
			}
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		protected void Uncapture()
		{
			int cap = Popcrawl();
			runmatch.RemoveMatch(cap);
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="cap">The capture number.</param>
		/// <returns>Returns <see cref="T:System.Boolean" />.</returns>
		protected bool IsMatched(int cap)
		{
			return runmatch.IsMatched(cap);
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="cap">The capture number.</param>
		/// <returns>Returns <see cref="T:System.Int32" />.</returns>
		protected int MatchIndex(int cap)
		{
			return runmatch.MatchIndex(cap);
		}

		/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
		/// <param name="cap">The capture number.</param>
		/// <returns>Returns <see cref="T:System.Int32" />.</returns>
		protected int MatchLength(int cap)
		{
			return runmatch.MatchLength(cap);
		}
	}
}
