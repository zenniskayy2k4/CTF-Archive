using System;

// Token: 0x02000001 RID: 1
internal class <Module>
{
}

using System;

// Token: 0x02000002 RID: 2
public class AnotherStraightLiner : EnemyBase
{
}

using System;
using UnityEngine;

// Token: 0x02000005 RID: 5
public class CameraFollow : MonoBehaviour
{
	// Token: 0x06000007 RID: 7 RVA: 0x000020B7 File Offset: 0x000002B7
	private void Start()
	{
		this.fixedZ = base.transform.position.z;
	}

	// Token: 0x06000008 RID: 8 RVA: 0x000020D0 File Offset: 0x000002D0
	private void LateUpdate()
	{
		if (this.target == null)
		{
			return;
		}
		float num = this.target.position.x + this.xOffset;
		float num2 = Mathf.Clamp(this.target.position.y, this.minY, this.maxY);
		Vector3 vector = new Vector3(num, num2, this.fixedZ);
		base.transform.position = Vector3.Lerp(base.transform.position, vector, this.smoothSpeed * Time.deltaTime);
	}

	// Token: 0x04000002 RID: 2
	public Transform target;

	// Token: 0x04000003 RID: 3
	[Header("Follow")]
	public float smoothSpeed = 5f;

	// Token: 0x04000004 RID: 4
	public float xOffset = 3f;

	// Token: 0x04000005 RID: 5
	[Header("Vertical Clamp")]
	public float minY = -2.5f;

	// Token: 0x04000006 RID: 6
	public float maxY = 2.5f;

	// Token: 0x04000007 RID: 7
	private float fixedZ;
}


using System;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

// Token: 0x02000015 RID: 21
public class ChatController : MonoBehaviour
{
	// Token: 0x0600003A RID: 58 RVA: 0x00002CE2 File Offset: 0x00000EE2
	private void OnEnable()
	{
		this.ChatInputField.onSubmit.AddListener(new UnityAction<string>(this.AddToChatOutput));
	}

	// Token: 0x0600003B RID: 59 RVA: 0x00002D00 File Offset: 0x00000F00
	private void OnDisable()
	{
		this.ChatInputField.onSubmit.RemoveListener(new UnityAction<string>(this.AddToChatOutput));
	}

	// Token: 0x0600003C RID: 60 RVA: 0x00002D20 File Offset: 0x00000F20
	private void AddToChatOutput(string newText)
	{
		this.ChatInputField.text = string.Empty;
		DateTime now = DateTime.Now;
		string text = string.Concat(new string[]
		{
			"[<#FFFF80>",
			now.Hour.ToString("d2"),
			":",
			now.Minute.ToString("d2"),
			":",
			now.Second.ToString("d2"),
			"</color>] ",
			newText
		});
		if (this.ChatDisplayOutput != null)
		{
			if (this.ChatDisplayOutput.text == string.Empty)
			{
				this.ChatDisplayOutput.text = text;
			}
			else
			{
				TMP_Text chatDisplayOutput = this.ChatDisplayOutput;
				chatDisplayOutput.text = chatDisplayOutput.text + "\n" + text;
			}
		}
		this.ChatInputField.ActivateInputField();
		this.ChatScrollbar.value = 0f;
	}

	// Token: 0x04000042 RID: 66
	public TMP_InputField ChatInputField;

	// Token: 0x04000043 RID: 67
	public TMP_Text ChatDisplayOutput;

	// Token: 0x04000044 RID: 68
	public Scrollbar ChatScrollbar;
}
using System;
using TMPro;
using UnityEngine;

// Token: 0x0200000F RID: 15
public class DistanceScoreManager : MonoBehaviour
{
	// Token: 0x0600002A RID: 42 RVA: 0x000029E2 File Offset: 0x00000BE2
	private void Awake()
	{
		if (DistanceScoreManager.Instance == null)
		{
			DistanceScoreManager.Instance = this;
			return;
		}
		Object.Destroy(base.gameObject);
	}

	// Token: 0x0600002B RID: 43 RVA: 0x00002A04 File Offset: 0x00000C04
	private void Start()
	{
		GameObject gameObject = GameObject.FindGameObjectWithTag("Player");
		if (gameObject != null)
		{
			this.player = gameObject.transform;
			this.startX = this.player.position.x;
		}
	}

	// Token: 0x0600002C RID: 44 RVA: 0x00002A48 File Offset: 0x00000C48
	private void Update()
	{
		if (!this.isRunning || this.player == null)
		{
			return;
		}
		float num = (this.player.position.x - this.startX) / this.unitsPerMeter;
		this.fractional += num;
		long num2 = (long)this.fractional;
		if (num2 != 0L)
		{
			this.currentDistance += num2;
			this.fractional -= (float)num2;
		}
		this.startX = this.player.position.x;
		if (this.distanceText != null)
		{
			this.distanceText.text = string.Format("{0} m", this.currentDistance);
		}
	}

	// Token: 0x0600002D RID: 45 RVA: 0x00002B05 File Offset: 0x00000D05
	public long GetDistance()
	{
		return this.currentDistance;
	}

	// Token: 0x0600002E RID: 46 RVA: 0x00002B0D File Offset: 0x00000D0D
	public void StopScoring()
	{
		this.isRunning = false;
	}

	// Token: 0x04000032 RID: 50
	public static DistanceScoreManager Instance;

	// Token: 0x04000033 RID: 51
	public TextMeshProUGUI distanceText;

	// Token: 0x04000034 RID: 52
	public long currentDistance;

	// Token: 0x04000035 RID: 53
	[Header("Tuning")]
	[Tooltip("How many Unity units = 1 meter of score. Bigger = slower score gain.")]
	public float unitsPerMeter = 3f;

	// Token: 0x04000036 RID: 54
	private Transform player;

	// Token: 0x04000037 RID: 55
	private float startX;

	// Token: 0x04000038 RID: 56
	private float fractional;

	// Token: 0x04000039 RID: 57
	private bool isRunning = true;
}

using System;
using TMPro;
using UnityEngine;

// Token: 0x02000016 RID: 22
public class DropdownSample : MonoBehaviour
{
	// Token: 0x0600003E RID: 62 RVA: 0x00002E2C File Offset: 0x0000102C
	public void OnButtonClick()
	{
		this.text.text = ((this.dropdownWithPlaceholder.value > -1) ? ("Selected values:\n" + this.dropdownWithoutPlaceholder.value.ToString() + " - " + this.dropdownWithPlaceholder.value.ToString()) : "Error: Please make a selection");
	}

	// Token: 0x04000045 RID: 69
	[SerializeField]
	private TextMeshProUGUI text;

	// Token: 0x04000046 RID: 70
	[SerializeField]
	private TMP_Dropdown dropdownWithoutPlaceholder;

	// Token: 0x04000047 RID: 71
	[SerializeField]
	private TMP_Dropdown dropdownWithPlaceholder;
}


using System;
using UnityEngine;

// Token: 0x02000006 RID: 6
public class EnemyBase : MonoBehaviour
{
	// Token: 0x0600000A RID: 10 RVA: 0x00002191 File Offset: 0x00000391
	protected virtual void Start()
	{
		GameObject gameObject = GameObject.FindGameObjectWithTag("Player");
		this.player = ((gameObject != null) ? gameObject.transform : null);
	}

	// Token: 0x0600000B RID: 11 RVA: 0x000021B0 File Offset: 0x000003B0
	protected virtual void Update()
	{
		base.transform.position += Vector3.left * this.worldScrollSpeed * Time.deltaTime;
		if (base.transform.position.x < this.destroyX)
		{
			Object.Destroy(base.gameObject);
		}
	}

	// Token: 0x0600000C RID: 12 RVA: 0x00002210 File Offset: 0x00000410
	private void OnTriggerEnter2D(Collider2D other)
	{
		if (other.CompareTag("Player"))
		{
			Object.Destroy(other.gameObject);
		}
	}

	// Token: 0x04000008 RID: 8
	[Header("World Scroll")]
	public float worldScrollSpeed = 2.5f;

	// Token: 0x04000009 RID: 9
	[Header("Cleanup")]
	public float destroyX = -12f;

	// Token: 0x0400000A RID: 10
	protected Transform player;
}


using System;
using UnityEngine;

// Token: 0x02000012 RID: 18
public class EnemyLockOn : EnemyBase
{
	// Token: 0x06000032 RID: 50 RVA: 0x00002B40 File Offset: 0x00000D40
	protected override void Update()
	{
		base.Update();
		if (!this.locked && this.player != null)
		{
			this.direction = (this.player.position - base.transform.position).normalized;
			this.locked = true;
		}
		base.transform.position += this.direction * this.diveSpeed * Time.deltaTime;
	}

	// Token: 0x0400003A RID: 58
	public float diveSpeed = 6f;

	// Token: 0x0400003B RID: 59
	private Vector3 direction;

	// Token: 0x0400003C RID: 60
	private bool locked;
}

using System;
using UnityEngine;

// Token: 0x02000007 RID: 7
public class EnemySpawner : MonoBehaviour
{
	// Token: 0x0600000E RID: 14 RVA: 0x00002248 File Offset: 0x00000448
	private void Start()
	{
		this.player = GameObject.FindGameObjectWithTag("Player").transform;
		base.InvokeRepeating("SpawnEnemy", 1f, this.spawnRate);
	}

	// Token: 0x0600000F RID: 15 RVA: 0x00002278 File Offset: 0x00000478
	private void SpawnEnemy()
	{
		Vector3 vector = new Vector3(this.player.position.x + this.spawnAheadDistance, Random.Range(this.minY, this.maxY), 0f);
		int num = Random.Range(0, this.enemyPrefabs.Length);
		Object.Instantiate<GameObject>(this.enemyPrefabs[num], vector, Quaternion.identity);
	}

	// Token: 0x0400000B RID: 11
	public GameObject[] enemyPrefabs;

	// Token: 0x0400000C RID: 12
	public float spawnRate = 1.5f;

	// Token: 0x0400000D RID: 13
	public float spawnAheadDistance = 12f;

	// Token: 0x0400000E RID: 14
	public float minY = -4f;

	// Token: 0x0400000F RID: 15
	public float maxY = 4f;

	// Token: 0x04000010 RID: 16
	private Transform player;
}

using System;
using UnityEngine;

// Token: 0x02000014 RID: 20
public class EnemyZigZag : EnemyBase
{
	// Token: 0x06000037 RID: 55 RVA: 0x00002C3A File Offset: 0x00000E3A
	protected override void Start()
	{
		base.Start();
		this.startY = base.transform.position.y;
	}

	// Token: 0x06000038 RID: 56 RVA: 0x00002C58 File Offset: 0x00000E58
	protected override void Update()
	{
		base.Update();
		this.time += Time.deltaTime;
		float num = Mathf.Sin(this.time * this.frequency) * this.amplitude;
		base.transform.position = new Vector3(base.transform.position.x, this.startY + num, 0f);
	}

	// Token: 0x0400003E RID: 62
	public float amplitude = 1.5f;

	// Token: 0x0400003F RID: 63
	public float frequency = 3f;

	// Token: 0x04000040 RID: 64
	private float startY;

	// Token: 0x04000041 RID: 65
	private float time;
}

using System;
using System.Collections;
using TMPro;
using UnityEngine;

// Token: 0x02000017 RID: 23
public class EnvMapAnimator : MonoBehaviour
{
	// Token: 0x06000040 RID: 64 RVA: 0x00002E96 File Offset: 0x00001096
	private void Awake()
	{
		this.m_textMeshPro = base.GetComponent<TMP_Text>();
		this.m_material = this.m_textMeshPro.fontSharedMaterial;
	}

	// Token: 0x06000041 RID: 65 RVA: 0x00002EB5 File Offset: 0x000010B5
	private IEnumerator Start()
	{
		Matrix4x4 matrix = default(Matrix4x4);
		for (;;)
		{
			matrix.SetTRS(Vector3.zero, Quaternion.Euler(Time.time * this.RotationSpeeds.x, Time.time * this.RotationSpeeds.y, Time.time * this.RotationSpeeds.z), Vector3.one);
			this.m_material.SetMatrix("_EnvMatrix", matrix);
			yield return null;
		}
		yield break;
	}

	// Token: 0x04000048 RID: 72
	public Vector3 RotationSpeeds;

	// Token: 0x04000049 RID: 73
	private TMP_Text m_textMeshPro;

	// Token: 0x0400004A RID: 74
	private Material m_material;
}

using System;
using System.Collections;
using UnityEngine;

// Token: 0x02000013 RID: 19
public class FirstTimeMovePrompt : MonoBehaviour
{
	// Token: 0x06000034 RID: 52 RVA: 0x00002BDD File Offset: 0x00000DDD
	private void Start()
	{
		if (PlayerPrefs.GetInt("HasSeenMovePrompt", 0) == 1)
		{
			base.gameObject.SetActive(false);
			return;
		}
		PlayerPrefs.SetInt("HasSeenMovePrompt", 1);
		PlayerPrefs.Save();
		base.StartCoroutine(this.HideAfterDelay(3f));
	}

	// Token: 0x06000035 RID: 53 RVA: 0x00002C1C File Offset: 0x00000E1C
	private IEnumerator HideAfterDelay(float delay)
	{
		yield return new WaitForSeconds(delay);
		base.gameObject.SetActive(false);
		yield break;
	}

	// Token: 0x0400003D RID: 61
	private const string SeenKey = "HasSeenMovePrompt";
}


using System;
using System.Text;
using UnityEngine;

// Token: 0x02000009 RID: 9
public class FlagGeneration : MonoBehaviour
{
	// Token: 0x06000013 RID: 19 RVA: 0x000023BC File Offset: 0x000005BC
	private string decryptFlag()
	{
		byte[] array = new byte[this.encryptedFlag.Length];
		for (int i = 0; i < this.encryptedFlag.Length; i++)
		{
			array[i] = this.encryptedFlag[i] ^ 90;
		}
		return Encoding.ASCII.GetString(array);
	}

	// Token: 0x0400001B RID: 27
	private const byte KEY = 90;

	// Token: 0x0400001C RID: 28
	private readonly byte[] encryptedFlag = new byte[]
	{
		33, 15, 55, 55, 5, 110, 57, 46, 47, 59,
		54, 54, 35, 5, 47, 52, 34, 106, 40, 107,
		107, 52, 61, 5, 46, 106, 5, 61, 105, 46,
		5, 60, 54, 110, 61, 5, 41, 105, 105, 55,
		41, 5, 46, 106, 106, 5, 105, 110, 41, 35,
		39
	};
}


using System;
using UnityEngine;

// Token: 0x02000004 RID: 4
public class FreezeCamera : MonoBehaviour
{
	// Token: 0x06000004 RID: 4 RVA: 0x00002089 File Offset: 0x00000289
	private void Start()
	{
		this.lockedPosition = base.transform.position;
	}

	// Token: 0x06000005 RID: 5 RVA: 0x0000209C File Offset: 0x0000029C
	private void LateUpdate()
	{
		base.transform.position = this.lockedPosition;
	}

	// Token: 0x04000001 RID: 1
	private Vector3 lockedPosition;
}


using System;
using UnityEngine;

// Token: 0x0200000A RID: 10
public class MusicManager : MonoBehaviour
{
	// Token: 0x06000015 RID: 21 RVA: 0x00002424 File Offset: 0x00000624
	private void Awake()
	{
		if (MusicManager.Instance != null && MusicManager.Instance != this)
		{
			Object.Destroy(base.gameObject);
			return;
		}
		MusicManager.Instance = this;
		Object.DontDestroyOnLoad(base.gameObject);
	}

	// Token: 0x0400001D RID: 29
	public static MusicManager Instance;
}


using System;
using System.Numerics;

// Token: 0x02000008 RID: 8
public class NotAFlag
{
	// Token: 0x04000011 RID: 17
	private static readonly BigInteger n1 = BigInteger.Parse("140381961641930398330540465696213028969126001789293759084168690349083690019678108299888584560875657190182582310493708655462512715310084936210814700738849281581483599741245065892285386331527569226522683354956666055877156704345642631707773421059828917552713496965692277736030519626761681726001638986623902908751");

	// Token: 0x04000012 RID: 18
	private static readonly BigInteger n2 = BigInteger.Parse("90132670250196962312040418206924311239901920480347853109113748669903967252091760606227621568551426880985565675756579792879966601343714824531386192667408271556520032438244925694617346837133966449332309941821902191387755086123823242212486098811676026127863095967844798559893634697520917638373758659170748524791");

	// Token: 0x04000013 RID: 19
	private static readonly BigInteger n3 = BigInteger.Parse("92870411975092354106330113489981684619075267931952431963207383921535685414674143610526594076913362723313054561118146675986010292295379944050301099078016525613058476042961835602721067517863998383626957693614148364726817700218631909324443350565414784901760585967079707026712823046847996935123027982618939886099");

	// Token: 0x04000014 RID: 20
	private static readonly BigInteger n4 = BigInteger.Parse("168059555628207778504375888035881426044835981952467770358529823850009975409545827224265127145252390709778182983957592941871668025957526028310511416584326667809546673007039538165201860636495505819314248935508818389785549318632537058046427379106735567855573276940662684040511611671890291496675392630131205961483");

	// Token: 0x04000015 RID: 21
	private static readonly BigInteger n5 = BigInteger.Parse("138034396036991389706797658430159925129995525872548933305836082672230043781436543029934469621530557873373633520728172265576476784793180864770981872062640337107363558045203951063816948439868397279766730591906554092820611115487671457427730293860647869487867000417172625616728421808332177952692109636658023859989");

	// Token: 0x04000016 RID: 22
	private static readonly BigInteger n6 = BigInteger.Parse("55626536668007217510949641122645412327044014854935434298524125055036919081822292467184288850410404053947027777897868139353157946510008373527301823842880665658689074282772022010163702636151067381493977104407406677771684796129627650403546381848523155873743934964755423092965833308116533403414561368599912036311");

	// Token: 0x04000017 RID: 23
	private static readonly BigInteger n7 = BigInteger.Parse("54997805237062806682383875815917050687516262553731872764463661050857073992957657816698321157684757490353958203052300557546201694279142171558099032722668134127146424659096876551702676155169502422766567542124479497442015324510950979471666938020568883110112425012571822109709531954723991284049525018465914288587");

	// Token: 0x04000018 RID: 24
	private static readonly BigInteger n8 = BigInteger.Parse("169970633954647104039023491730681812038427736660346334001939825800042291226071195982871351206222066891916150982755902508271558681056111586781204391903379735737720180147643453825314538841715818708978697706449978814262056729744012631024872360721357469148552731374466484484469021044872879353152330684550012652109");

	// Token: 0x04000019 RID: 25
	private static readonly BigInteger n9 = BigInteger.Parse("106902071352915984150549328305612335895567090807862539866486992753096987036702349597403951136701581579491041268047155545494610873761061810539113268415450784496116636384211392440032054491049484310654987104496305125813347244053695061494278552279474350695908134897865061427665051776402519838609309686356630825963");

	// Token: 0x0400001A RID: 26
	private static readonly BigInteger ciphertext = BigInteger.Parse("14996700735916458687112441777842842054090704625269557715272569050214748003961319009899728685148968128542653518784232681136496554530102914969196164062063502000537572784734510320204713297482927939610141129919523922191811250570574595270961936155845892704851175233230735534380952934192952409048057287286287235882");
}


using System;
using UnityEngine;

// Token: 0x0200000B RID: 11
public class ParallaxFollowCamera : MonoBehaviour
{
	// Token: 0x06000017 RID: 23 RVA: 0x00002468 File Offset: 0x00000668
	private void Start()
	{
		this.cam = Camera.main.transform;
		this.lastCamPos = this.cam.position;
		this.spriteWidths = new float[this.layerRoots.Length];
		for (int i = 0; i < this.layerRoots.Length; i++)
		{
			SpriteRenderer component = this.layerRoots[i].GetChild(0).GetComponent<SpriteRenderer>();
			this.spriteWidths[i] = component.bounds.size.x;
		}
	}

	// Token: 0x06000018 RID: 24 RVA: 0x000024EC File Offset: 0x000006EC
	private void LateUpdate()
	{
		Vector3 vector = this.cam.position - this.lastCamPos;
		for (int i = 0; i < this.layerRoots.Length; i++)
		{
			Transform transform = this.layerRoots[i];
			float num = this.parallaxFactors[i];
			float num2 = this.spriteWidths[i];
			int childCount = transform.childCount;
			transform.position += new Vector3(vector.x * num, 0f, 0f);
			for (int j = 0; j < childCount; j++)
			{
				Transform child = transform.GetChild(j);
				if (child.position.x < this.cam.position.x - num2)
				{
					child.position += Vector3.right * num2 * (float)childCount;
				}
			}
		}
		this.lastCamPos = this.cam.position;
	}

	// Token: 0x0400001E RID: 30
	[Header("Layers")]
	public Transform[] layerRoots;

	// Token: 0x0400001F RID: 31
	public float[] parallaxFactors;

	// Token: 0x04000020 RID: 32
	private Transform cam;

	// Token: 0x04000021 RID: 33
	private Vector3 lastCamPos;

	// Token: 0x04000022 RID: 34
	private float[] spriteWidths;
}


using System;
using UnityEngine;

// Token: 0x0200000C RID: 12
public class PlayerDeathManager : MonoBehaviour
{
	// Token: 0x0600001A RID: 26 RVA: 0x000025F0 File Offset: 0x000007F0
	private void Awake()
	{
		if (PlayerDeathManager.Instance == null)
		{
			PlayerDeathManager.Instance = this;
			return;
		}
		Object.Destroy(base.gameObject);
	}

	// Token: 0x0600001B RID: 27 RVA: 0x00002614 File Offset: 0x00000814
	public void HandlePlayerDeath()
	{
		Debug.Log("PLAYER DEATH TRIGGERED");
		if (this.hasDied)
		{
			return;
		}
		this.hasDied = true;
		DistanceScoreManager instance = DistanceScoreManager.Instance;
		if (instance != null)
		{
			instance.StopScoring();
		}
		this.DespawnAllEnemies();
		Time.timeScale = 0f;
		if (this.deathScreenUI != null)
		{
			this.deathScreenUI.SetActive(true);
		}
	}

	// Token: 0x0600001C RID: 28 RVA: 0x00002678 File Offset: 0x00000878
	private void DespawnAllEnemies()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(this.enemyTag);
		for (int i = 0; i < array.Length; i++)
		{
			Object.Destroy(array[i]);
		}
		foreach (GameObject gameObject in Object.FindObjectsOfType<GameObject>())
		{
			if (((1 << gameObject.layer) & this.enemyLayer) != 0)
			{
				Object.Destroy(gameObject);
			}
		}
	}

	// Token: 0x04000023 RID: 35
	public static PlayerDeathManager Instance;

	// Token: 0x04000024 RID: 36
	[Header("Death Screen")]
	public GameObject deathScreenUI;

	// Token: 0x04000025 RID: 37
	[Header("Enemy Cleanup")]
	public string enemyTag = "Enemy";

	// Token: 0x04000026 RID: 38
	public LayerMask enemyLayer;

	// Token: 0x04000027 RID: 39
	private bool hasDied;
}


using System;
using UnityEngine;
using UnityEngine.SceneManagement;

// Token: 0x02000003 RID: 3
public class RetryButton : MonoBehaviour
{
	// Token: 0x06000002 RID: 2 RVA: 0x00002058 File Offset: 0x00000258
	public void Retry()
	{
		Time.timeScale = 1f;
		SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
	}
}


using System;
using UnityEngine;
using UnityEngine.UI;

// Token: 0x0200000E RID: 14
public class ScoreManaged : MonoBehaviour
{
	// Token: 0x06000024 RID: 36 RVA: 0x00002897 File Offset: 0x00000A97
	private void Start()
	{
		if (this.flagImage != null)
		{
			this.flagImage.gameObject.SetActive(false);
		}
		if (this.retryScreenUI != null)
		{
			this.retryScreenUI.SetActive(false);
		}
	}

	// Token: 0x06000025 RID: 37 RVA: 0x000028D2 File Offset: 0x00000AD2
	private void Update()
	{
		if (this.flagUnlocked)
		{
			return;
		}
		if (this.GetCurrentScore() >= this.requiredDistance)
		{
			this.flagUnlocked = true;
			this.ShowFlagAndRetry();
		}
	}

	// Token: 0x06000026 RID: 38 RVA: 0x000028F8 File Offset: 0x00000AF8
	private float GetCurrentScore()
	{
		if (this.useManualScore)
		{
			return this.manualScore;
		}
		if (DistanceScoreManager.Instance == null)
		{
			return 0f;
		}
		return (float)DistanceScoreManager.Instance.GetDistance();
	}

	// Token: 0x06000027 RID: 39 RVA: 0x00002928 File Offset: 0x00000B28
	private void ShowFlagAndRetry()
	{
		if (this.flagImage != null)
		{
			this.flagImage.gameObject.SetActive(true);
		}
		if (this.retryScreenUI != null)
		{
			this.retryScreenUI.SetActive(true);
		}
		Time.timeScale = 0f;
	}

	// Token: 0x06000028 RID: 40 RVA: 0x00002978 File Offset: 0x00000B78
	public void ResetFlag()
	{
		this.flagUnlocked = false;
		if (this.flagImage != null)
		{
			this.flagImage.gameObject.SetActive(false);
		}
		if (this.retryScreenUI != null)
		{
			this.retryScreenUI.SetActive(false);
		}
		Time.timeScale = 1f;
	}

	// Token: 0x0400002C RID: 44
	[Header("Score Requirement")]
	public float requiredDistance = 1000000f;

	// Token: 0x0400002D RID: 45
	[Header("Score Source")]
	public bool useManualScore;

	// Token: 0x0400002E RID: 46
	public float manualScore;

	// Token: 0x0400002F RID: 47
	[Header("UI")]
	public Image flagImage;

	// Token: 0x04000030 RID: 48
	public GameObject retryScreenUI;

	// Token: 0x04000031 RID: 49
	private bool flagUnlocked;
}


using System;
using UnityEngine;

// Token: 0x0200000D RID: 13
public class ShipMovement : MonoBehaviour
{
	// Token: 0x0600001E RID: 30 RVA: 0x000026F1 File Offset: 0x000008F1
	private void Start()
	{
		this.cam = Camera.main;
	}

	// Token: 0x0600001F RID: 31 RVA: 0x00002700 File Offset: 0x00000900
	private void Update()
	{
		float axisRaw = Input.GetAxisRaw("Horizontal");
		float axisRaw2 = Input.GetAxisRaw("Vertical");
		Vector3 vector = new Vector3(axisRaw, axisRaw2, 0f) * this.speed;
		Vector3 vector2 = Vector3.right * this.forwardSpeed;
		base.transform.position += (vector + vector2) * Time.deltaTime;
		this.ClampToCamera();
	}

	// Token: 0x06000020 RID: 32 RVA: 0x00002778 File Offset: 0x00000978
	private void ClampToCamera()
	{
		Vector3 vector = this.cam.ViewportToWorldPoint(new Vector3(0f, 0f, 0f));
		Vector3 vector2 = this.cam.ViewportToWorldPoint(new Vector3(1f, 1f, 0f));
		float num = vector.x + this.padding;
		float num2 = vector2.x - this.padding;
		float num3 = vector.y + this.padding;
		float num4 = vector2.y - this.padding;
		float num5 = Mathf.Clamp(base.transform.position.x, num, num2);
		float num6 = Mathf.Clamp(base.transform.position.y, num3, num4);
		base.transform.position = new Vector3(num5, num6, 0f);
	}

	// Token: 0x06000021 RID: 33 RVA: 0x00002848 File Offset: 0x00000A48
	private void OnTriggerEnter2D(Collider2D other)
	{
		if (other.CompareTag("Enemy"))
		{
			this.Die();
		}
	}

	// Token: 0x06000022 RID: 34 RVA: 0x0000285D File Offset: 0x00000A5D
	private void Die()
	{
		PlayerDeathManager instance = PlayerDeathManager.Instance;
		if (instance == null)
		{
			return;
		}
		instance.HandlePlayerDeath();
	}

	// Token: 0x04000028 RID: 40
	[Header("Movement")]
	public float speed = 8f;

	// Token: 0x04000029 RID: 41
	public float forwardSpeed = 4f;

	// Token: 0x0400002A RID: 42
	[Header("Screen Clamp")]
	public float padding = 0.5f;

	// Token: 0x0400002B RID: 43
	private Camera cam;
}
using System;

// Token: 0x02000010 RID: 16
public class Stander : EnemyBase
{
}

using System;

// Token: 0x02000011 RID: 17
public class StraightLiner : EnemyBase
{
}


using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

// Token: 0x02000018 RID: 24
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	// Token: 0x06000043 RID: 67 RVA: 0x00002ECC File Offset: 0x000010CC
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static UnitySourceGeneratedAssemblyMonoScriptTypes_v1.MonoScriptData Get()
	{
		UnitySourceGeneratedAssemblyMonoScriptTypes_v1.MonoScriptData monoScriptData = default(UnitySourceGeneratedAssemblyMonoScriptTypes_v1.MonoScriptData);
		monoScriptData.FilePathsData = new byte[]
		{
			0, 0, 0, 1, 0, 0, 0, 39, 92, 65,
			115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 65, 110, 111, 116, 104, 101,
			114, 83, 116, 114, 97, 105, 103, 104, 116, 76,
			105, 110, 101, 114, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 25, 92, 65, 115, 115, 101,
			116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 66, 117, 116, 116, 111, 110, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 30, 92, 65,
			115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 67, 97, 109, 101, 114, 97,
			67, 108, 97, 109, 112, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 31, 92, 65, 115, 115,
			101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
			115, 92, 67, 97, 109, 101, 114, 97, 70, 111,
			108, 108, 111, 119, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 28, 92, 65, 115, 115, 101,
			116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 69, 110, 101, 109, 121, 77, 97, 105, 110,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			31, 92, 65, 115, 115, 101, 116, 115, 92, 83,
			99, 114, 105, 112, 116, 115, 92, 69, 110, 101,
			109, 121, 83, 112, 97, 119, 110, 101, 114, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 23,
			92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
			114, 105, 112, 116, 115, 92, 70, 108, 97, 103,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			39, 92, 65, 115, 115, 101, 116, 115, 92, 83,
			99, 114, 105, 112, 116, 115, 92, 70, 108, 97,
			103, 71, 101, 110, 101, 114, 97, 116, 105, 111,
			110, 83, 99, 114, 105, 112, 116, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 32, 92, 65,
			115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 77, 117, 115, 105, 105, 99,
			77, 97, 110, 97, 103, 101, 114, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 37, 92, 65,
			115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 80, 97, 114, 97, 108, 108,
			97, 120, 67, 111, 110, 116, 114, 111, 108, 108,
			101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 37, 92, 65, 115, 115, 101, 116, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 80,
			108, 97, 121, 101, 114, 68, 101, 97, 116, 104,
			77, 97, 110, 97, 103, 101, 114, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 34, 92, 65,
			115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 80, 108, 108, 97, 121, 101,
			114, 77, 111, 118, 101, 109, 101, 110, 116, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 34,
			92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
			114, 105, 112, 116, 115, 92, 83, 99, 111, 114,
			101, 65, 99, 99, 111, 117, 110, 116, 97, 110,
			116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 31, 92, 65, 115, 115, 101, 116, 115, 92,
			83, 99, 114, 105, 112, 116, 115, 92, 83, 99,
			111, 114, 101, 77, 97, 110, 97, 103, 101, 114,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			26, 92, 65, 115, 115, 101, 116, 115, 92, 83,
			99, 114, 105, 112, 116, 115, 92, 83, 116, 97,
			110, 100, 101, 114, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 32, 92, 65, 115, 115, 101,
			116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 83, 116, 114, 97, 105, 103, 104, 116, 76,
			105, 110, 101, 114, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 27, 92, 65, 115, 115, 101,
			116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 84, 97, 114, 103, 101, 116, 101, 114, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 27,
			92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
			114, 105, 112, 116, 115, 92, 84, 117, 116, 111,
			114, 105, 97, 108, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 28, 92, 65, 115, 115, 101,
			116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 90, 105, 103, 90, 97, 103, 103, 101, 114,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			61, 92, 65, 115, 115, 101, 116, 115, 92, 84,
			101, 120, 116, 77, 101, 115, 104, 32, 80, 114,
			111, 92, 69, 120, 97, 109, 112, 108, 101, 115,
			32, 38, 32, 69, 120, 116, 114, 97, 115, 92,
			83, 99, 114, 105, 112, 116, 115, 92, 66, 101,
			110, 99, 104, 109, 97, 114, 107, 48, 49, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 66,
			92, 65, 115, 115, 101, 116, 115, 92, 84, 101,
			120, 116, 77, 101, 115, 104, 32, 80, 114, 111,
			92, 69, 120, 97, 109, 112, 108, 101, 115, 32,
			38, 32, 69, 120, 116, 114, 97, 115, 92, 83,
			99, 114, 105, 112, 116, 115, 92, 66, 101, 110,
			99, 104, 109, 97, 114, 107, 48, 49, 95, 85,
			71, 85, 73, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 61, 92, 65, 115, 115, 101, 116,
			115, 92, 84, 101, 120, 116, 77, 101, 115, 104,
			32, 80, 114, 111, 92, 69, 120, 97, 109, 112,
			108, 101, 115, 32, 38, 32, 69, 120, 116, 114,
			97, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 66, 101, 110, 99, 104, 109, 97, 114, 107,
			48, 50, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 61, 92, 65, 115, 115, 101, 116, 115,
			92, 84, 101, 120, 116, 77, 101, 115, 104, 32,
			80, 114, 111, 92, 69, 120, 97, 109, 112, 108,
			101, 115, 32, 38, 32, 69, 120, 116, 114, 97,
			115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
			66, 101, 110, 99, 104, 109, 97, 114, 107, 48,
			51, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 61, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
			101, 110, 99, 104, 109, 97, 114, 107, 48, 52,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			66, 92, 65, 115, 115, 101, 116, 115, 92, 84,
			101, 120, 116, 77, 101, 115, 104, 32, 80, 114,
			111, 92, 69, 120, 97, 109, 112, 108, 101, 115,
			32, 38, 32, 69, 120, 116, 114, 97, 115, 92,
			83, 99, 114, 105, 112, 116, 115, 92, 67, 97,
			109, 101, 114, 97, 67, 111, 110, 116, 114, 111,
			108, 108, 101, 114, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 64, 92, 65, 115, 115, 101,
			116, 115, 92, 84, 101, 120, 116, 77, 101, 115,
			104, 32, 80, 114, 111, 92, 69, 120, 97, 109,
			112, 108, 101, 115, 32, 38, 32, 69, 120, 116,
			114, 97, 115, 92, 83, 99, 114, 105, 112, 116,
			115, 92, 67, 104, 97, 116, 67, 111, 110, 116,
			114, 111, 108, 108, 101, 114, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 64, 92, 65, 115,
			115, 101, 116, 115, 92, 84, 101, 120, 116, 77,
			101, 115, 104, 32, 80, 114, 111, 92, 69, 120,
			97, 109, 112, 108, 101, 115, 32, 38, 32, 69,
			120, 116, 114, 97, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 68, 114, 111, 112, 100, 111,
			119, 110, 83, 97, 109, 112, 108, 101, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 64, 92,
			65, 115, 115, 101, 116, 115, 92, 84, 101, 120,
			116, 77, 101, 115, 104, 32, 80, 114, 111, 92,
			69, 120, 97, 109, 112, 108, 101, 115, 32, 38,
			32, 69, 120, 116, 114, 97, 115, 92, 83, 99,
			114, 105, 112, 116, 115, 92, 69, 110, 118, 77,
			97, 112, 65, 110, 105, 109, 97, 116, 111, 114,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			60, 92, 65, 115, 115, 101, 116, 115, 92, 84,
			101, 120, 116, 77, 101, 115, 104, 32, 80, 114,
			111, 92, 69, 120, 97, 109, 112, 108, 101, 115,
			32, 38, 32, 69, 120, 116, 114, 97, 115, 92,
			83, 99, 114, 105, 112, 116, 115, 92, 79, 98,
			106, 101, 99, 116, 83, 112, 105, 110, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 68, 92,
			65, 115, 115, 101, 116, 115, 92, 84, 101, 120,
			116, 77, 101, 115, 104, 32, 80, 114, 111, 92,
			69, 120, 97, 109, 112, 108, 101, 115, 32, 38,
			32, 69, 120, 116, 114, 97, 115, 92, 83, 99,
			114, 105, 112, 116, 115, 92, 83, 104, 97, 100,
			101, 114, 80, 114, 111, 112, 65, 110, 105, 109,
			97, 116, 111, 114, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 62, 92, 65, 115, 115, 101,
			116, 115, 92, 84, 101, 120, 116, 77, 101, 115,
			104, 32, 80, 114, 111, 92, 69, 120, 97, 109,
			112, 108, 101, 115, 32, 38, 32, 69, 120, 116,
			114, 97, 115, 92, 83, 99, 114, 105, 112, 116,
			115, 92, 83, 105, 109, 112, 108, 101, 83, 99,
			114, 105, 112, 116, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 65, 92, 65, 115, 115, 101,
			116, 115, 92, 84, 101, 120, 116, 77, 101, 115,
			104, 32, 80, 114, 111, 92, 69, 120, 97, 109,
			112, 108, 101, 115, 32, 38, 32, 69, 120, 116,
			114, 97, 115, 92, 83, 99, 114, 105, 112, 116,
			115, 92, 83, 107, 101, 119, 84, 101, 120, 116,
			69, 120, 97, 109, 112, 108, 101, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 58, 92, 65,
			115, 115, 101, 116, 115, 92, 84, 101, 120, 116,
			77, 101, 115, 104, 32, 80, 114, 111, 92, 69,
			120, 97, 109, 112, 108, 101, 115, 32, 38, 32,
			69, 120, 116, 114, 97, 115, 92, 83, 99, 114,
			105, 112, 116, 115, 92, 84, 101, 108, 101, 84,
			121, 112, 101, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 70, 92, 65, 115, 115, 101, 116,
			115, 92, 84, 101, 120, 116, 77, 101, 115, 104,
			32, 80, 114, 111, 92, 69, 120, 97, 109, 112,
			108, 101, 115, 32, 38, 32, 69, 120, 116, 114,
			97, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 84, 101, 120, 116, 67, 111, 110, 115, 111,
			108, 101, 83, 105, 109, 117, 108, 97, 116, 111,
			114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 73, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
			101, 120, 116, 77, 101, 115, 104, 80, 114, 111,
			70, 108, 111, 97, 116, 105, 110, 103, 84, 101,
			120, 116, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 65, 92, 65, 115, 115, 101, 116, 115,
			92, 84, 101, 120, 116, 77, 101, 115, 104, 32,
			80, 114, 111, 92, 69, 120, 97, 109, 112, 108,
			101, 115, 32, 38, 32, 69, 120, 116, 114, 97,
			115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 83, 112,
			97, 119, 110, 101, 114, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 74, 92, 65, 115, 115,
			101, 116, 115, 92, 84, 101, 120, 116, 77, 101,
			115, 104, 32, 80, 114, 111, 92, 69, 120, 97,
			109, 112, 108, 101, 115, 32, 38, 32, 69, 120,
			116, 114, 97, 115, 92, 83, 99, 114, 105, 112,
			116, 115, 92, 84, 77, 80, 114, 111, 95, 73,
			110, 115, 116, 114, 117, 99, 116, 105, 111, 110,
			79, 118, 101, 114, 108, 97, 121, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 68, 92, 65,
			115, 115, 101, 116, 115, 92, 84, 101, 120, 116,
			77, 101, 115, 104, 32, 80, 114, 111, 92, 69,
			120, 97, 109, 112, 108, 101, 115, 32, 38, 32,
			69, 120, 116, 114, 97, 115, 92, 83, 99, 114,
			105, 112, 116, 115, 92, 84, 77, 80, 95, 68,
			105, 103, 105, 116, 86, 97, 108, 105, 100, 97,
			116, 111, 114, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 70, 92, 65, 115, 115, 101, 116,
			115, 92, 84, 101, 120, 116, 77, 101, 115, 104,
			32, 80, 114, 111, 92, 69, 120, 97, 109, 112,
			108, 101, 115, 32, 38, 32, 69, 120, 116, 114,
			97, 115, 92, 83, 99, 114, 105, 112, 116, 115,
			92, 84, 77, 80, 95, 69, 120, 97, 109, 112,
			108, 101, 83, 99, 114, 105, 112, 116, 95, 48,
			49, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 70, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
			77, 80, 95, 70, 114, 97, 109, 101, 82, 97,
			116, 101, 67, 111, 117, 110, 116, 101, 114, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 74,
			92, 65, 115, 115, 101, 116, 115, 92, 84, 101,
			120, 116, 77, 101, 115, 104, 32, 80, 114, 111,
			92, 69, 120, 97, 109, 112, 108, 101, 115, 32,
			38, 32, 69, 120, 116, 114, 97, 115, 92, 83,
			99, 114, 105, 112, 116, 115, 92, 84, 77, 80,
			95, 80, 104, 111, 110, 101, 78, 117, 109, 98,
			101, 114, 86, 97, 108, 105, 100, 97, 116, 111,
			114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 68, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
			77, 80, 95, 84, 101, 120, 116, 69, 118, 101,
			110, 116, 67, 104, 101, 99, 107, 46, 99, 115,
			0, 0, 0, 6, 0, 0, 0, 70, 92, 65,
			115, 115, 101, 116, 115, 92, 84, 101, 120, 116,
			77, 101, 115, 104, 32, 80, 114, 111, 92, 69,
			120, 97, 109, 112, 108, 101, 115, 32, 38, 32,
			69, 120, 116, 114, 97, 115, 92, 83, 99, 114,
			105, 112, 116, 115, 92, 84, 77, 80, 95, 84,
			101, 120, 116, 69, 118, 101, 110, 116, 72, 97,
			110, 100, 108, 101, 114, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 71, 92, 65, 115, 115,
			101, 116, 115, 92, 84, 101, 120, 116, 77, 101,
			115, 104, 32, 80, 114, 111, 92, 69, 120, 97,
			109, 112, 108, 101, 115, 32, 38, 32, 69, 120,
			116, 114, 97, 115, 92, 83, 99, 114, 105, 112,
			116, 115, 92, 84, 77, 80, 95, 84, 101, 120,
			116, 73, 110, 102, 111, 68, 101, 98, 117, 103,
			84, 111, 111, 108, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 68, 92, 65, 115, 115, 101,
			116, 115, 92, 84, 101, 120, 116, 77, 101, 115,
			104, 32, 80, 114, 111, 92, 69, 120, 97, 109,
			112, 108, 101, 115, 32, 38, 32, 69, 120, 116,
			114, 97, 115, 92, 83, 99, 114, 105, 112, 116,
			115, 92, 84, 77, 80, 95, 84, 101, 120, 116,
			83, 101, 108, 101, 99, 116, 111, 114, 95, 65,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			68, 92, 65, 115, 115, 101, 116, 115, 92, 84,
			101, 120, 116, 77, 101, 115, 104, 32, 80, 114,
			111, 92, 69, 120, 97, 109, 112, 108, 101, 115,
			32, 38, 32, 69, 120, 116, 114, 97, 115, 92,
			83, 99, 114, 105, 112, 116, 115, 92, 84, 77,
			80, 95, 84, 101, 120, 116, 83, 101, 108, 101,
			99, 116, 111, 114, 95, 66, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 72, 92, 65, 115,
			115, 101, 116, 115, 92, 84, 101, 120, 116, 77,
			101, 115, 104, 32, 80, 114, 111, 92, 69, 120,
			97, 109, 112, 108, 101, 115, 32, 38, 32, 69,
			120, 116, 114, 97, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 84, 77, 80, 95, 85, 105,
			70, 114, 97, 109, 101, 82, 97, 116, 101, 67,
			111, 117, 110, 116, 101, 114, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 67, 92, 65, 115,
			115, 101, 116, 115, 92, 84, 101, 120, 116, 77,
			101, 115, 104, 32, 80, 114, 111, 92, 69, 120,
			97, 109, 112, 108, 101, 115, 32, 38, 32, 69,
			120, 116, 114, 97, 115, 92, 83, 99, 114, 105,
			112, 116, 115, 92, 86, 101, 114, 116, 101, 120,
			67, 111, 108, 111, 114, 67, 121, 99, 108, 101,
			114, 46, 99, 115, 0, 0, 0, 2, 0, 0,
			0, 62, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
			101, 114, 116, 101, 120, 74, 105, 116, 116, 101,
			114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 62, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
			101, 114, 116, 101, 120, 83, 104, 97, 107, 101,
			65, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 62, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
			101, 114, 116, 101, 120, 83, 104, 97, 107, 101,
			66, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 60, 92, 65, 115, 115, 101, 116, 115, 92,
			84, 101, 120, 116, 77, 101, 115, 104, 32, 80,
			114, 111, 92, 69, 120, 97, 109, 112, 108, 101,
			115, 32, 38, 32, 69, 120, 116, 114, 97, 115,
			92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
			101, 114, 116, 101, 120, 90, 111, 111, 109, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 65,
			92, 65, 115, 115, 101, 116, 115, 92, 84, 101,
			120, 116, 77, 101, 115, 104, 32, 80, 114, 111,
			92, 69, 120, 97, 109, 112, 108, 101, 115, 32,
			38, 32, 69, 120, 116, 114, 97, 115, 92, 83,
			99, 114, 105, 112, 116, 115, 92, 87, 97, 114,
			112, 84, 101, 120, 116, 69, 120, 97, 109, 112,
			108, 101, 46, 99, 115
		};
		monoScriptData.TypesData = new byte[]
		{
			0, 0, 0, 0, 21, 124, 65, 110, 111, 116,
			104, 101, 114, 83, 116, 114, 97, 105, 103, 104,
			116, 76, 105, 110, 101, 114, 0, 0, 0, 0,
			12, 124, 82, 101, 116, 114, 121, 66, 117, 116,
			116, 111, 110, 0, 0, 0, 0, 13, 124, 70,
			114, 101, 101, 122, 101, 67, 97, 109, 101, 114,
			97, 0, 0, 0, 0, 13, 124, 67, 97, 109,
			101, 114, 97, 70, 111, 108, 108, 111, 119, 0,
			0, 0, 0, 10, 124, 69, 110, 101, 109, 121,
			66, 97, 115, 101, 0, 0, 0, 0, 13, 124,
			69, 110, 101, 109, 121, 83, 112, 97, 119, 110,
			101, 114, 0, 0, 0, 0, 9, 124, 78, 111,
			116, 65, 70, 108, 97, 103, 0, 0, 0, 0,
			15, 124, 70, 108, 97, 103, 71, 101, 110, 101,
			114, 97, 116, 105, 111, 110, 0, 0, 0, 0,
			13, 124, 77, 117, 115, 105, 99, 77, 97, 110,
			97, 103, 101, 114, 0, 0, 0, 0, 21, 124,
			80, 97, 114, 97, 108, 108, 97, 120, 70, 111,
			108, 108, 111, 119, 67, 97, 109, 101, 114, 97,
			0, 0, 0, 0, 19, 124, 80, 108, 97, 121,
			101, 114, 68, 101, 97, 116, 104, 77, 97, 110,
			97, 103, 101, 114, 0, 0, 0, 0, 13, 124,
			83, 104, 105, 112, 77, 111, 118, 101, 109, 101,
			110, 116, 0, 0, 0, 0, 13, 124, 83, 99,
			111, 114, 101, 77, 97, 110, 97, 103, 101, 100,
			0, 0, 0, 0, 21, 124, 68, 105, 115, 116,
			97, 110, 99, 101, 83, 99, 111, 114, 101, 77,
			97, 110, 97, 103, 101, 114, 0, 0, 0, 0,
			8, 124, 83, 116, 97, 110, 100, 101, 114, 0,
			0, 0, 0, 14, 124, 83, 116, 114, 97, 105,
			103, 104, 116, 76, 105, 110, 101, 114, 0, 0,
			0, 0, 12, 124, 69, 110, 101, 109, 121, 76,
			111, 99, 107, 79, 110, 0, 0, 0, 0, 20,
			124, 70, 105, 114, 115, 116, 84, 105, 109, 101,
			77, 111, 118, 101, 80, 114, 111, 109, 112, 116,
			0, 0, 0, 0, 12, 124, 69, 110, 101, 109,
			121, 90, 105, 103, 90, 97, 103, 0, 0, 0,
			0, 26, 84, 77, 80, 114, 111, 46, 69, 120,
			97, 109, 112, 108, 101, 115, 124, 66, 101, 110,
			99, 104, 109, 97, 114, 107, 48, 49, 0, 0,
			0, 0, 31, 84, 77, 80, 114, 111, 46, 69,
			120, 97, 109, 112, 108, 101, 115, 124, 66, 101,
			110, 99, 104, 109, 97, 114, 107, 48, 49, 95,
			85, 71, 85, 73, 0, 0, 0, 0, 26, 84,
			77, 80, 114, 111, 46, 69, 120, 97, 109, 112,
			108, 101, 115, 124, 66, 101, 110, 99, 104, 109,
			97, 114, 107, 48, 50, 0, 0, 0, 0, 26,
			84, 77, 80, 114, 111, 46, 69, 120, 97, 109,
			112, 108, 101, 115, 124, 66, 101, 110, 99, 104,
			109, 97, 114, 107, 48, 51, 0, 0, 0, 0,
			26, 84, 77, 80, 114, 111, 46, 69, 120, 97,
			109, 112, 108, 101, 115, 124, 66, 101, 110, 99,
			104, 109, 97, 114, 107, 48, 52, 0, 0, 0,
			0, 31, 84, 77, 80, 114, 111, 46, 69, 120,
			97, 109, 112, 108, 101, 115, 124, 67, 97, 109,
			101, 114, 97, 67, 111, 110, 116, 114, 111, 108,
			108, 101, 114, 0, 0, 0, 0, 15, 124, 67,
			104, 97, 116, 67, 111, 110, 116, 114, 111, 108,
			108, 101, 114, 0, 0, 0, 0, 15, 124, 68,
			114, 111, 112, 100, 111, 119, 110, 83, 97, 109,
			112, 108, 101, 0, 0, 0, 0, 15, 124, 69,
			110, 118, 77, 97, 112, 65, 110, 105, 109, 97,
			116, 111, 114, 0, 0, 0, 0, 25, 84, 77,
			80, 114, 111, 46, 69, 120, 97, 109, 112, 108,
			101, 115, 124, 79, 98, 106, 101, 99, 116, 83,
			112, 105, 110, 0, 0, 0, 0, 33, 84, 77,
			80, 114, 111, 46, 69, 120, 97, 109, 112, 108,
			101, 115, 124, 83, 104, 97, 100, 101, 114, 80,
			114, 111, 112, 65, 110, 105, 109, 97, 116, 111,
			114, 0, 0, 0, 0, 27, 84, 77, 80, 114,
			111, 46, 69, 120, 97, 109, 112, 108, 101, 115,
			124, 83, 105, 109, 112, 108, 101, 83, 99, 114,
			105, 112, 116, 0, 0, 0, 0, 30, 84, 77,
			80, 114, 111, 46, 69, 120, 97, 109, 112, 108,
			101, 115, 124, 83, 107, 101, 119, 84, 101, 120,
			116, 69, 120, 97, 109, 112, 108, 101, 0, 0,
			0, 0, 23, 84, 77, 80, 114, 111, 46, 69,
			120, 97, 109, 112, 108, 101, 115, 124, 84, 101,
			108, 101, 84, 121, 112, 101, 0, 0, 0, 0,
			35, 84, 77, 80, 114, 111, 46, 69, 120, 97,
			109, 112, 108, 101, 115, 124, 84, 101, 120, 116,
			67, 111, 110, 115, 111, 108, 101, 83, 105, 109,
			117, 108, 97, 116, 111, 114, 0, 0, 0, 0,
			38, 84, 77, 80, 114, 111, 46, 69, 120, 97,
			109, 112, 108, 101, 115, 124, 84, 101, 120, 116,
			77, 101, 115, 104, 80, 114, 111, 70, 108, 111,
			97, 116, 105, 110, 103, 84, 101, 120, 116, 0,
			0, 0, 0, 30, 84, 77, 80, 114, 111, 46,
			69, 120, 97, 109, 112, 108, 101, 115, 124, 84,
			101, 120, 116, 77, 101, 115, 104, 83, 112, 97,
			119, 110, 101, 114, 0, 0, 0, 0, 39, 84,
			77, 80, 114, 111, 46, 69, 120, 97, 109, 112,
			108, 101, 115, 124, 84, 77, 80, 114, 111, 95,
			73, 110, 115, 116, 114, 117, 99, 116, 105, 111,
			110, 79, 118, 101, 114, 108, 97, 121, 0, 0,
			0, 0, 24, 84, 77, 80, 114, 111, 124, 84,
			77, 80, 95, 68, 105, 103, 105, 116, 86, 97,
			108, 105, 100, 97, 116, 111, 114, 0, 0, 0,
			0, 35, 84, 77, 80, 114, 111, 46, 69, 120,
			97, 109, 112, 108, 101, 115, 124, 84, 77, 80,
			95, 69, 120, 97, 109, 112, 108, 101, 83, 99,
			114, 105, 112, 116, 95, 48, 49, 0, 0, 0,
			0, 35, 84, 77, 80, 114, 111, 46, 69, 120,
			97, 109, 112, 108, 101, 115, 124, 84, 77, 80,
			95, 70, 114, 97, 109, 101, 82, 97, 116, 101,
			67, 111, 117, 110, 116, 101, 114, 0, 0, 0,
			0, 30, 84, 77, 80, 114, 111, 124, 84, 77,
			80, 95, 80, 104, 111, 110, 101, 78, 117, 109,
			98, 101, 114, 86, 97, 108, 105, 100, 97, 116,
			111, 114, 0, 0, 0, 0, 33, 84, 77, 80,
			114, 111, 46, 69, 120, 97, 109, 112, 108, 101,
			115, 124, 84, 77, 80, 95, 84, 101, 120, 116,
			69, 118, 101, 110, 116, 67, 104, 101, 99, 107,
			0, 0, 0, 0, 26, 84, 77, 80, 114, 111,
			124, 84, 77, 80, 95, 84, 101, 120, 116, 69,
			118, 101, 110, 116, 72, 97, 110, 100, 108, 101,
			114, 0, 0, 0, 0, 50, 84, 77, 80, 114,
			111, 46, 84, 77, 80, 95, 84, 101, 120, 116,
			69, 118, 101, 110, 116, 72, 97, 110, 100, 108,
			101, 114, 124, 67, 104, 97, 114, 97, 99, 116,
			101, 114, 83, 101, 108, 101, 99, 116, 105, 111,
			110, 69, 118, 101, 110, 116, 0, 0, 0, 0,
			47, 84, 77, 80, 114, 111, 46, 84, 77, 80,
			95, 84, 101, 120, 116, 69, 118, 101, 110, 116,
			72, 97, 110, 100, 108, 101, 114, 124, 83, 112,
			114, 105, 116, 101, 83, 101, 108, 101, 99, 116,
			105, 111, 110, 69, 118, 101, 110, 116, 0, 0,
			0, 0, 45, 84, 77, 80, 114, 111, 46, 84,
			77, 80, 95, 84, 101, 120, 116, 69, 118, 101,
			110, 116, 72, 97, 110, 100, 108, 101, 114, 124,
			87, 111, 114, 100, 83, 101, 108, 101, 99, 116,
			105, 111, 110, 69, 118, 101, 110, 116, 0, 0,
			0, 0, 45, 84, 77, 80, 114, 111, 46, 84,
			77, 80, 95, 84, 101, 120, 116, 69, 118, 101,
			110, 116, 72, 97, 110, 100, 108, 101, 114, 124,
			76, 105, 110, 101, 83, 101, 108, 101, 99, 116,
			105, 111, 110, 69, 118, 101, 110, 116, 0, 0,
			0, 0, 45, 84, 77, 80, 114, 111, 46, 84,
			77, 80, 95, 84, 101, 120, 116, 69, 118, 101,
			110, 116, 72, 97, 110, 100, 108, 101, 114, 124,
			76, 105, 110, 107, 83, 101, 108, 101, 99, 116,
			105, 111, 110, 69, 118, 101, 110, 116, 0, 0,
			0, 0, 36, 84, 77, 80, 114, 111, 46, 69,
			120, 97, 109, 112, 108, 101, 115, 124, 84, 77,
			80, 95, 84, 101, 120, 116, 73, 110, 102, 111,
			68, 101, 98, 117, 103, 84, 111, 111, 108, 0,
			0, 0, 0, 33, 84, 77, 80, 114, 111, 46,
			69, 120, 97, 109, 112, 108, 101, 115, 124, 84,
			77, 80, 95, 84, 101, 120, 116, 83, 101, 108,
			101, 99, 116, 111, 114, 95, 65, 0, 0, 0,
			0, 33, 84, 77, 80, 114, 111, 46, 69, 120,
			97, 109, 112, 108, 101, 115, 124, 84, 77, 80,
			95, 84, 101, 120, 116, 83, 101, 108, 101, 99,
			116, 111, 114, 95, 66, 0, 0, 0, 0, 37,
			84, 77, 80, 114, 111, 46, 69, 120, 97, 109,
			112, 108, 101, 115, 124, 84, 77, 80, 95, 85,
			105, 70, 114, 97, 109, 101, 82, 97, 116, 101,
			67, 111, 117, 110, 116, 101, 114, 0, 0, 0,
			0, 32, 84, 77, 80, 114, 111, 46, 69, 120,
			97, 109, 112, 108, 101, 115, 124, 86, 101, 114,
			116, 101, 120, 67, 111, 108, 111, 114, 67, 121,
			99, 108, 101, 114, 0, 0, 0, 0, 27, 84,
			77, 80, 114, 111, 46, 69, 120, 97, 109, 112,
			108, 101, 115, 124, 86, 101, 114, 116, 101, 120,
			74, 105, 116, 116, 101, 114, 0, 0, 0, 0,
			38, 84, 77, 80, 114, 111, 46, 69, 120, 97,
			109, 112, 108, 101, 115, 46, 86, 101, 114, 116,
			101, 120, 74, 105, 116, 116, 101, 114, 124, 86,
			101, 114, 116, 101, 120, 65, 110, 105, 109, 0,
			0, 0, 0, 27, 84, 77, 80, 114, 111, 46,
			69, 120, 97, 109, 112, 108, 101, 115, 124, 86,
			101, 114, 116, 101, 120, 83, 104, 97, 107, 101,
			65, 0, 0, 0, 0, 27, 84, 77, 80, 114,
			111, 46, 69, 120, 97, 109, 112, 108, 101, 115,
			124, 86, 101, 114, 116, 101, 120, 83, 104, 97,
			107, 101, 66, 0, 0, 0, 0, 25, 84, 77,
			80, 114, 111, 46, 69, 120, 97, 109, 112, 108,
			101, 115, 124, 86, 101, 114, 116, 101, 120, 90,
			111, 111, 109, 0, 0, 0, 0, 30, 84, 77,
			80, 114, 111, 46, 69, 120, 97, 109, 112, 108,
			101, 115, 124, 87, 97, 114, 112, 84, 101, 120,
			116, 69, 120, 97, 109, 112, 108, 101
		};
		monoScriptData.TotalFiles = 53;
		monoScriptData.TotalTypes = 59;
		monoScriptData.IsEditorOnly = false;
		return monoScriptData;
	}

	// Token: 0x0200003B RID: 59
	private struct MonoScriptData
	{
		// Token: 0x04000116 RID: 278
		public byte[] FilePathsData;

		// Token: 0x04000117 RID: 279
		public byte[] TypesData;

		// Token: 0x04000118 RID: 280
		public int TotalTypes;

		// Token: 0x04000119 RID: 281
		public int TotalFiles;

		// Token: 0x0400011A RID: 282
		public bool IsEditorOnly;
	}
}



using System;



namespace TMPro

{

    // Token: 0x02000019 RID: 25

    [Serializable]

    public class TMP_DigitValidator : TMP_InputValidator

    {

        // Token: 0x06000045 RID: 69 RVA: 0x00002F3C File Offset: 0x0000113C

        public override char Validate(ref string text, ref int pos, char ch)

        {

            if (ch >= '0' && ch <= '9')

            {

                text += ch.ToString();

                pos++;

                return ch;

            }

            return '\0';

        }

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x0200001C RID: 28

    public class Benchmark01 : MonoBehaviour

    {

        // Token: 0x0600005D RID: 93 RVA: 0x000035BA File Offset: 0x000017BA

        private IEnumerator Start()

        {

            if (this.BenchmarkType == 0)

            {

                this.m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();

                this.m_textMeshPro.autoSizeTextContainer = true;

                if (this.TMProFont != null)

                {

                    this.m_textMeshPro.font = this.TMProFont;

                }

                this.m_textMeshPro.fontSize = 48f;

                this.m_textMeshPro.alignment = TextAlignmentOptions.Center;

                this.m_textMeshPro.extraPadding = true;

                this.m_textMeshPro.textWrappingMode = TextWrappingModes.NoWrap;

                this.m_material01 = this.m_textMeshPro.font.material;

                this.m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Drop Shadow");

            }

            else if (this.BenchmarkType == 1)

            {

                this.m_textMesh = base.gameObject.AddComponent<TextMesh>();

                if (this.TextMeshFont != null)

                {

                    this.m_textMesh.font = this.TextMeshFont;

                    this.m_textMesh.GetComponent<Renderer>().sharedMaterial = this.m_textMesh.font.material;

                }

                else

                {

                    this.m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;

                    this.m_textMesh.GetComponent<Renderer>().sharedMaterial = this.m_textMesh.font.material;

                }

                this.m_textMesh.fontSize = 48;

                this.m_textMesh.anchor = TextAnchor.MiddleCenter;

            }

            int num;

            for (int i = 0; i <= 1000000; i = num + 1)

            {

                if (this.BenchmarkType == 0)

                {

                    this.m_textMeshPro.SetText("The <#0050FF>count is: </color>{0}", (float)(i % 1000));

                    if (i % 1000 == 999)

                    {

                        this.m_textMeshPro.fontSharedMaterial = ((this.m_textMeshPro.fontSharedMaterial == this.m_material01) ? (this.m_textMeshPro.fontSharedMaterial = this.m_material02) : (this.m_textMeshPro.fontSharedMaterial = this.m_material01));

                    }

                }

                else if (this.BenchmarkType == 1)

                {

                    this.m_textMesh.text = "The <color=#0050FF>count is: </color>" + (i % 1000).ToString();

                }

                yield return null;

                num = i;

            }

            yield return null;

            yield break;

        }



        // Token: 0x04000057 RID: 87

        public int BenchmarkType;



        // Token: 0x04000058 RID: 88

        public TMP_FontAsset TMProFont;



        // Token: 0x04000059 RID: 89

        public Font TextMeshFont;



        // Token: 0x0400005A RID: 90

        private TextMeshPro m_textMeshPro;



        // Token: 0x0400005B RID: 91

        private TextContainer m_textContainer;



        // Token: 0x0400005C RID: 92

        private TextMesh m_textMesh;



        // Token: 0x0400005D RID: 93

        private const string label01 = "The <#0050FF>count is: </color>{0}";



        // Token: 0x0400005E RID: 94

        private const string label02 = "The <color=#0050FF>count is: </color>";



        // Token: 0x0400005F RID: 95

        private Material m_material01;



        // Token: 0x04000060 RID: 96

        private Material m_material02;

    }

}



using System;

using System.Collections;

using UnityEngine;

using UnityEngine.UI;



namespace TMPro.Examples

{

    // Token: 0x0200001D RID: 29

    public class Benchmark01_UGUI : MonoBehaviour

    {

        // Token: 0x0600005F RID: 95 RVA: 0x000035D1 File Offset: 0x000017D1

        private IEnumerator Start()

        {

            if (this.BenchmarkType == 0)

            {

                this.m_textMeshPro = base.gameObject.AddComponent<TextMeshProUGUI>();

                if (this.TMProFont != null)

                {

                    this.m_textMeshPro.font = this.TMProFont;

                }

                this.m_textMeshPro.fontSize = 48f;

                this.m_textMeshPro.alignment = TextAlignmentOptions.Center;

                this.m_textMeshPro.extraPadding = true;

                this.m_material01 = this.m_textMeshPro.font.material;

                this.m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - BEVEL");

            }

            else if (this.BenchmarkType == 1)

            {

                this.m_textMesh = base.gameObject.AddComponent<Text>();

                if (this.TextMeshFont != null)

                {

                    this.m_textMesh.font = this.TextMeshFont;

                }

                this.m_textMesh.fontSize = 48;

                this.m_textMesh.alignment = TextAnchor.MiddleCenter;

            }

            int num;

            for (int i = 0; i <= 1000000; i = num + 1)

            {

                if (this.BenchmarkType == 0)

                {

                    this.m_textMeshPro.text = "The <#0050FF>count is: </color>" + (i % 1000).ToString();

                    if (i % 1000 == 999)

                    {

                        this.m_textMeshPro.fontSharedMaterial = ((this.m_textMeshPro.fontSharedMaterial == this.m_material01) ? (this.m_textMeshPro.fontSharedMaterial = this.m_material02) : (this.m_textMeshPro.fontSharedMaterial = this.m_material01));

                    }

                }

                else if (this.BenchmarkType == 1)

                {

                    this.m_textMesh.text = "The <color=#0050FF>count is: </color>" + (i % 1000).ToString();

                }

                yield return null;

                num = i;

            }

            yield return null;

            yield break;

        }



        // Token: 0x04000061 RID: 97

        public int BenchmarkType;



        // Token: 0x04000062 RID: 98

        public Canvas canvas;



        // Token: 0x04000063 RID: 99

        public TMP_FontAsset TMProFont;



        // Token: 0x04000064 RID: 100

        public Font TextMeshFont;



        // Token: 0x04000065 RID: 101

        private TextMeshProUGUI m_textMeshPro;



        // Token: 0x04000066 RID: 102

        private Text m_textMesh;



        // Token: 0x04000067 RID: 103

        private const string label01 = "The <#0050FF>count is: </color>";



        // Token: 0x04000068 RID: 104

        private const string label02 = "The <color=#0050FF>count is: </color>";



        // Token: 0x04000069 RID: 105

        private Material m_material01;



        // Token: 0x0400006A RID: 106

        private Material m_material02;

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x0200001E RID: 30

    public class Benchmark02 : MonoBehaviour

    {

        // Token: 0x06000061 RID: 97 RVA: 0x000035E8 File Offset: 0x000017E8

        private void Start()

        {

            for (int i = 0; i < this.NumberOfNPC; i++)

            {

                if (this.SpawnType == 0)

                {

                    GameObject gameObject = new GameObject();

                    gameObject.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));

                    TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();

                    textMeshPro.autoSizeTextContainer = true;

                    textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0f);

                    textMeshPro.alignment = TextAlignmentOptions.Bottom;

                    textMeshPro.fontSize = 96f;

                    textMeshPro.fontFeatures.Clear();

                    textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);

                    textMeshPro.text = "!";

                    textMeshPro.isTextObjectScaleStatic = this.IsTextObjectScaleStatic;

                    this.floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();

                    this.floatingText_Script.SpawnType = 0;

                    this.floatingText_Script.IsTextObjectScaleStatic = this.IsTextObjectScaleStatic;

                }

                else if (this.SpawnType == 1)

                {

                    GameObject gameObject2 = new GameObject();

                    gameObject2.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));

                    TextMesh textMesh = gameObject2.AddComponent<TextMesh>();

                    textMesh.font = Resources.Load<Font>("Fonts/ARIAL");

                    textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material;

                    textMesh.anchor = TextAnchor.LowerCenter;

                    textMesh.fontSize = 96;

                    textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);

                    textMesh.text = "!";

                    this.floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();

                    this.floatingText_Script.SpawnType = 1;

                }

                else if (this.SpawnType == 2)

                {

                    GameObject gameObject3 = new GameObject();

                    gameObject3.AddComponent<Canvas>().worldCamera = Camera.main;

                    gameObject3.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);

                    gameObject3.transform.position = new Vector3(Random.Range(-95f, 95f), 5f, Random.Range(-95f, 95f));

                    TextMeshProUGUI textMeshProUGUI = new GameObject().AddComponent<TextMeshProUGUI>();

                    textMeshProUGUI.rectTransform.SetParent(gameObject3.transform, false);

                    textMeshProUGUI.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);

                    textMeshProUGUI.alignment = TextAlignmentOptions.Bottom;

                    textMeshProUGUI.fontSize = 96f;

                    textMeshProUGUI.text = "!";

                    this.floatingText_Script = gameObject3.AddComponent<TextMeshProFloatingText>();

                    this.floatingText_Script.SpawnType = 0;

                }

            }

        }



        // Token: 0x0400006B RID: 107

        public int SpawnType;



        // Token: 0x0400006C RID: 108

        public int NumberOfNPC = 12;



        // Token: 0x0400006D RID: 109

        public bool IsTextObjectScaleStatic;



        // Token: 0x0400006E RID: 110

        private TextMeshProFloatingText floatingText_Script;

    }

}



using System;

using UnityEngine;

using UnityEngine.TextCore.LowLevel;



namespace TMPro.Examples

{

    // Token: 0x0200001F RID: 31

    public class Benchmark03 : MonoBehaviour

    {

        // Token: 0x06000063 RID: 99 RVA: 0x000038C3 File Offset: 0x00001AC3

        private void Awake()

        {

        }



        // Token: 0x06000064 RID: 100 RVA: 0x000038C8 File Offset: 0x00001AC8

        private void Start()

        {

            TMP_FontAsset tmp_FontAsset = null;

            switch (this.Benchmark)

            {

            case Benchmark03.BenchmarkType.TMP_SDF_MOBILE:

                tmp_FontAsset = TMP_FontAsset.CreateFontAsset(this.SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic, true);

                break;

            case Benchmark03.BenchmarkType.TMP_SDF__MOBILE_SSD:

                tmp_FontAsset = TMP_FontAsset.CreateFontAsset(this.SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic, true);

                tmp_FontAsset.material.shader = Shader.Find("TextMeshPro/Mobile/Distance Field SSD");

                break;

            case Benchmark03.BenchmarkType.TMP_SDF:

                tmp_FontAsset = TMP_FontAsset.CreateFontAsset(this.SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic, true);

                tmp_FontAsset.material.shader = Shader.Find("TextMeshPro/Distance Field");

                break;

            case Benchmark03.BenchmarkType.TMP_BITMAP_MOBILE:

                tmp_FontAsset = TMP_FontAsset.CreateFontAsset(this.SourceFont, 90, 9, GlyphRenderMode.SMOOTH, 256, 256, AtlasPopulationMode.Dynamic, true);

                break;

            }

            for (int i = 0; i < this.NumberOfSamples; i++)

            {

                Benchmark03.BenchmarkType benchmark = this.Benchmark;

                if (benchmark > Benchmark03.BenchmarkType.TMP_BITMAP_MOBILE)

                {

                    if (benchmark == Benchmark03.BenchmarkType.TEXTMESH_BITMAP)

                    {

                        TextMesh textMesh = new GameObject

                        {

                            transform = 

                            {

                                position = new Vector3(0f, 1.2f, 0f)

                            }

                        }.AddComponent<TextMesh>();

                        textMesh.GetComponent<Renderer>().sharedMaterial = this.SourceFont.material;

                        textMesh.font = this.SourceFont;

                        textMesh.anchor = TextAnchor.MiddleCenter;

                        textMesh.fontSize = 130;

                        textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);

                        textMesh.text = "@";

                    }

                }

                else

                {

                    TextMeshPro textMeshPro = new GameObject

                    {

                        transform = 

                        {

                            position = new Vector3(0f, 1.2f, 0f)

                        }

                    }.AddComponent<TextMeshPro>();

                    textMeshPro.font = tmp_FontAsset;

                    textMeshPro.fontSize = 128f;

                    textMeshPro.text = "@";

                    textMeshPro.alignment = TextAlignmentOptions.Center;

                    textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);

                    if (this.Benchmark == Benchmark03.BenchmarkType.TMP_BITMAP_MOBILE)

                    {

                        textMeshPro.fontSize = 132f;

                    }

                }

            }

        }



        // Token: 0x0400006F RID: 111

        public int NumberOfSamples = 100;



        // Token: 0x04000070 RID: 112

        public Benchmark03.BenchmarkType Benchmark;



        // Token: 0x04000071 RID: 113

        public Font SourceFont;



        // Token: 0x02000043 RID: 67

        public enum BenchmarkType

        {

            // Token: 0x04000124 RID: 292

            TMP_SDF_MOBILE,

            // Token: 0x04000125 RID: 293

            TMP_SDF__MOBILE_SSD,

            // Token: 0x04000126 RID: 294

            TMP_SDF,

            // Token: 0x04000127 RID: 295

            TMP_BITMAP_MOBILE,

            // Token: 0x04000128 RID: 296

            TEXTMESH_BITMAP

        }

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000020 RID: 32

    public class Benchmark04 : MonoBehaviour

    {

        // Token: 0x06000066 RID: 102 RVA: 0x00003B04 File Offset: 0x00001D04

        private void Start()

        {

            this.m_Transform = base.transform;

            float num = 0f;

            float num2 = (Camera.main.orthographicSize = (float)(Screen.height / 2));

            float num3 = (float)Screen.width / (float)Screen.height;

            for (int i = this.MinPointSize; i <= this.MaxPointSize; i += this.Steps)

            {

                if (this.SpawnType == 0)

                {

                    GameObject gameObject = new GameObject("Text - " + i.ToString() + " Pts");

                    if (num > num2 * 2f)

                    {

                        return;

                    }

                    gameObject.transform.position = this.m_Transform.position + new Vector3(num3 * -num2 * 0.975f, num2 * 0.975f - num, 0f);

                    TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();

                    textMeshPro.rectTransform.pivot = new Vector2(0f, 0.5f);

                    textMeshPro.textWrappingMode = TextWrappingModes.NoWrap;

                    textMeshPro.extraPadding = true;

                    textMeshPro.isOrthographic = true;

                    textMeshPro.fontSize = (float)i;

                    textMeshPro.text = i.ToString() + " pts - Lorem ipsum dolor sit...";

                    textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

                    num += (float)i;

                }

            }

        }



        // Token: 0x04000072 RID: 114

        public int SpawnType;



        // Token: 0x04000073 RID: 115

        public int MinPointSize = 12;



        // Token: 0x04000074 RID: 116

        public int MaxPointSize = 64;



        // Token: 0x04000075 RID: 117

        public int Steps = 4;



        // Token: 0x04000076 RID: 118

        private Transform m_Transform;

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000021 RID: 33

    public class CameraController : MonoBehaviour

    {

        // Token: 0x06000068 RID: 104 RVA: 0x00003C78 File Offset: 0x00001E78

        private void Awake()

        {

            if (QualitySettings.vSyncCount > 0)

            {

                Application.targetFrameRate = 60;

            }

            else

            {

                Application.targetFrameRate = -1;

            }

            if (Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.Android)

            {

                Input.simulateMouseWithTouches = false;

            }

            this.cameraTransform = base.transform;

            this.previousSmoothing = this.MovementSmoothing;

        }



        // Token: 0x06000069 RID: 105 RVA: 0x00003CCB File Offset: 0x00001ECB

        private void Start()

        {

            if (this.CameraTarget == null)

            {

                this.dummyTarget = new GameObject("Camera Target").transform;

                this.CameraTarget = this.dummyTarget;

            }

        }



        // Token: 0x0600006A RID: 106 RVA: 0x00003CFC File Offset: 0x00001EFC

        private void LateUpdate()

        {

            this.GetPlayerInput();

            if (this.CameraTarget != null)

            {

                if (this.CameraMode == CameraController.CameraModes.Isometric)

                {

                    this.desiredPosition = this.CameraTarget.position + Quaternion.Euler(this.ElevationAngle, this.OrbitalAngle, 0f) * new Vector3(0f, 0f, -this.FollowDistance);

                }

                else if (this.CameraMode == CameraController.CameraModes.Follow)

                {

                    this.desiredPosition = this.CameraTarget.position + this.CameraTarget.TransformDirection(Quaternion.Euler(this.ElevationAngle, this.OrbitalAngle, 0f) * new Vector3(0f, 0f, -this.FollowDistance));

                }

                if (this.MovementSmoothing)

                {

                    this.cameraTransform.position = Vector3.SmoothDamp(this.cameraTransform.position, this.desiredPosition, ref this.currentVelocity, this.MovementSmoothingValue * Time.fixedDeltaTime);

                }

                else

                {

                    this.cameraTransform.position = this.desiredPosition;

                }

                if (this.RotationSmoothing)

                {

                    this.cameraTransform.rotation = Quaternion.Lerp(this.cameraTransform.rotation, Quaternion.LookRotation(this.CameraTarget.position - this.cameraTransform.position), this.RotationSmoothingValue * Time.deltaTime);

                    return;

                }

                this.cameraTransform.LookAt(this.CameraTarget);

            }

        }



        // Token: 0x0600006B RID: 107 RVA: 0x00003E7C File Offset: 0x0000207C

        private void GetPlayerInput()

        {

            this.moveVector = Vector3.zero;

            this.mouseWheel = Input.GetAxis("Mouse ScrollWheel");

            float num = (float)Input.touchCount;

            if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || num > 0f)

            {

                this.mouseWheel *= 10f;

                if (Input.GetKeyDown(KeyCode.I))

                {

                    this.CameraMode = CameraController.CameraModes.Isometric;

                }

                if (Input.GetKeyDown(KeyCode.F))

                {

                    this.CameraMode = CameraController.CameraModes.Follow;

                }

                if (Input.GetKeyDown(KeyCode.S))

                {

                    this.MovementSmoothing = !this.MovementSmoothing;

                }

                if (Input.GetMouseButton(1))

                {

                    this.mouseY = Input.GetAxis("Mouse Y");

                    this.mouseX = Input.GetAxis("Mouse X");

                    if (this.mouseY > 0.01f || this.mouseY < -0.01f)

                    {

                        this.ElevationAngle -= this.mouseY * this.MoveSensitivity;

                        this.ElevationAngle = Mathf.Clamp(this.ElevationAngle, this.MinElevationAngle, this.MaxElevationAngle);

                    }

                    if (this.mouseX > 0.01f || this.mouseX < -0.01f)

                    {

                        this.OrbitalAngle += this.mouseX * this.MoveSensitivity;

                        if (this.OrbitalAngle > 360f)

                        {

                            this.OrbitalAngle -= 360f;

                        }

                        if (this.OrbitalAngle < 0f)

                        {

                            this.OrbitalAngle += 360f;

                        }

                    }

                }

                if (num == 1f && Input.GetTouch(0).phase == TouchPhase.Moved)

                {

                    Vector2 deltaPosition = Input.GetTouch(0).deltaPosition;

                    if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f)

                    {

                        this.ElevationAngle -= deltaPosition.y * 0.1f;

                        this.ElevationAngle = Mathf.Clamp(this.ElevationAngle, this.MinElevationAngle, this.MaxElevationAngle);

                    }

                    if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f)

                    {

                        this.OrbitalAngle += deltaPosition.x * 0.1f;

                        if (this.OrbitalAngle > 360f)

                        {

                            this.OrbitalAngle -= 360f;

                        }

                        if (this.OrbitalAngle < 0f)

                        {

                            this.OrbitalAngle += 360f;

                        }

                    }

                }

                RaycastHit raycastHit;

                if (Input.GetMouseButton(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out raycastHit, 300f, 23552))

                {

                    if (raycastHit.transform == this.CameraTarget)

                    {

                        this.OrbitalAngle = 0f;

                    }

                    else

                    {

                        this.CameraTarget = raycastHit.transform;

                        this.OrbitalAngle = 0f;

                        this.MovementSmoothing = this.previousSmoothing;

                    }

                }

                if (Input.GetMouseButton(2))

                {

                    if (this.dummyTarget == null)

                    {

                        this.dummyTarget = new GameObject("Camera Target").transform;

                        this.dummyTarget.position = this.CameraTarget.position;

                        this.dummyTarget.rotation = this.CameraTarget.rotation;

                        this.CameraTarget = this.dummyTarget;

                        this.previousSmoothing = this.MovementSmoothing;

                        this.MovementSmoothing = false;

                    }

                    else if (this.dummyTarget != this.CameraTarget)

                    {

                        this.dummyTarget.position = this.CameraTarget.position;

                        this.dummyTarget.rotation = this.CameraTarget.rotation;

                        this.CameraTarget = this.dummyTarget;

                        this.previousSmoothing = this.MovementSmoothing;

                        this.MovementSmoothing = false;

                    }

                    this.mouseY = Input.GetAxis("Mouse Y");

                    this.mouseX = Input.GetAxis("Mouse X");

                    this.moveVector = this.cameraTransform.TransformDirection(this.mouseX, this.mouseY, 0f);

                    this.dummyTarget.Translate(-this.moveVector, Space.World);

                }

            }

            if (num == 2f)

            {

                Touch touch = Input.GetTouch(0);

                Touch touch2 = Input.GetTouch(1);

                Vector2 vector = touch.position - touch.deltaPosition;

                Vector2 vector2 = touch2.position - touch2.deltaPosition;

                float magnitude = (vector - vector2).magnitude;

                float magnitude2 = (touch.position - touch2.position).magnitude;

                float num2 = magnitude - magnitude2;

                if (num2 > 0.01f || num2 < -0.01f)

                {

                    this.FollowDistance += num2 * 0.25f;

                    this.FollowDistance = Mathf.Clamp(this.FollowDistance, this.MinFollowDistance, this.MaxFollowDistance);

                }

            }

            if (this.mouseWheel < -0.01f || this.mouseWheel > 0.01f)

            {

                this.FollowDistance -= this.mouseWheel * 5f;

                this.FollowDistance = Mathf.Clamp(this.FollowDistance, this.MinFollowDistance, this.MaxFollowDistance);

            }

        }



        // Token: 0x04000077 RID: 119

        private Transform cameraTransform;



        // Token: 0x04000078 RID: 120

        private Transform dummyTarget;



        // Token: 0x04000079 RID: 121

        public Transform CameraTarget;



        // Token: 0x0400007A RID: 122

        public float FollowDistance = 30f;



        // Token: 0x0400007B RID: 123

        public float MaxFollowDistance = 100f;



        // Token: 0x0400007C RID: 124

        public float MinFollowDistance = 2f;



        // Token: 0x0400007D RID: 125

        public float ElevationAngle = 30f;



        // Token: 0x0400007E RID: 126

        public float MaxElevationAngle = 85f;



        // Token: 0x0400007F RID: 127

        public float MinElevationAngle;



        // Token: 0x04000080 RID: 128

        public float OrbitalAngle;



        // Token: 0x04000081 RID: 129

        public CameraController.CameraModes CameraMode;



        // Token: 0x04000082 RID: 130

        public bool MovementSmoothing = true;



        // Token: 0x04000083 RID: 131

        public bool RotationSmoothing;



        // Token: 0x04000084 RID: 132

        private bool previousSmoothing;



        // Token: 0x04000085 RID: 133

        public float MovementSmoothingValue = 25f;



        // Token: 0x04000086 RID: 134

        public float RotationSmoothingValue = 5f;



        // Token: 0x04000087 RID: 135

        public float MoveSensitivity = 2f;



        // Token: 0x04000088 RID: 136

        private Vector3 currentVelocity = Vector3.zero;



        // Token: 0x04000089 RID: 137

        private Vector3 desiredPosition;



        // Token: 0x0400008A RID: 138

        private float mouseX;



        // Token: 0x0400008B RID: 139

        private float mouseY;



        // Token: 0x0400008C RID: 140

        private Vector3 moveVector;



        // Token: 0x0400008D RID: 141

        private float mouseWheel;



        // Token: 0x0400008E RID: 142

        private const string event_SmoothingValue = "Slider - Smoothing Value";



        // Token: 0x0400008F RID: 143

        private const string event_FollowDistance = "Slider - Camera Zoom";



        // Token: 0x02000044 RID: 68

        public enum CameraModes

        {

            // Token: 0x0400012A RID: 298

            Follow,

            // Token: 0x0400012B RID: 299

            Isometric,

            // Token: 0x0400012C RID: 300

            Free

        }

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000022 RID: 34

    public class ObjectSpin : MonoBehaviour

    {

        // Token: 0x0600006D RID: 109 RVA: 0x00004420 File Offset: 0x00002620

        private void Awake()

        {

            this.m_transform = base.transform;

            this.m_initial_Rotation = this.m_transform.rotation.eulerAngles;

            this.m_initial_Position = this.m_transform.position;

            Light component = base.GetComponent<Light>();

            this.m_lightColor = ((component != null) ? component.color : Color.black);

        }



        // Token: 0x0600006E RID: 110 RVA: 0x0000448C File Offset: 0x0000268C

        private void Update()

        {

            switch (this.Motion)

            {

            case ObjectSpin.MotionType.Rotation:

                this.m_transform.Rotate(0f, this.SpinSpeed * Time.deltaTime, 0f);

                return;

            case ObjectSpin.MotionType.SearchLight:

                this.m_time += this.SpinSpeed * Time.deltaTime;

                this.m_transform.rotation = Quaternion.Euler(this.m_initial_Rotation.x, Mathf.Sin(this.m_time) * (float)this.RotationRange + this.m_initial_Rotation.y, this.m_initial_Rotation.z);

                return;

            case ObjectSpin.MotionType.Translation:

            {

                this.m_time += this.TranslationSpeed * Time.deltaTime;

                float num = this.TranslationDistance.x * Mathf.Cos(this.m_time);

                float num2 = this.TranslationDistance.y * Mathf.Sin(this.m_time) * Mathf.Cos(this.m_time * 1f);

                float num3 = this.TranslationDistance.z * Mathf.Sin(this.m_time);

                this.m_transform.position = this.m_initial_Position + new Vector3(num, num3, num2);

                this.m_prevPOS = this.m_transform.position;

                return;

            }

            default:

                return;

            }

        }



        // Token: 0x04000090 RID: 144

        public ObjectSpin.MotionType Motion;



        // Token: 0x04000091 RID: 145

        public Vector3 TranslationDistance = new Vector3(5f, 0f, 0f);



        // Token: 0x04000092 RID: 146

        public float TranslationSpeed = 1f;



        // Token: 0x04000093 RID: 147

        public float SpinSpeed = 5f;



        // Token: 0x04000094 RID: 148

        public int RotationRange = 15;



        // Token: 0x04000095 RID: 149

        private Transform m_transform;



        // Token: 0x04000096 RID: 150

        private float m_time;



        // Token: 0x04000097 RID: 151

        private Vector3 m_prevPOS;



        // Token: 0x04000098 RID: 152

        private Vector3 m_initial_Rotation;



        // Token: 0x04000099 RID: 153

        private Vector3 m_initial_Position;



        // Token: 0x0400009A RID: 154

        private Color32 m_lightColor;



        // Token: 0x02000045 RID: 69

        public enum MotionType

        {

            // Token: 0x0400012E RID: 302

            Rotation,

            // Token: 0x0400012F RID: 303

            SearchLight,

            // Token: 0x04000130 RID: 304

            Translation

        }

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000023 RID: 35

    public class ShaderPropAnimator : MonoBehaviour

    {

        // Token: 0x06000070 RID: 112 RVA: 0x00004616 File Offset: 0x00002816

        private void Awake()

        {

            this.m_Renderer = base.GetComponent<Renderer>();

            this.m_Material = this.m_Renderer.material;

        }



        // Token: 0x06000071 RID: 113 RVA: 0x00004635 File Offset: 0x00002835

        private void Start()

        {

            base.StartCoroutine(this.AnimateProperties());

        }



        // Token: 0x06000072 RID: 114 RVA: 0x00004644 File Offset: 0x00002844

        private IEnumerator AnimateProperties()

        {

            this.m_frame = Random.Range(0f, 1f);

            for (;;)

            {

                float num = this.GlowCurve.Evaluate(this.m_frame);

                this.m_Material.SetFloat(ShaderUtilities.ID_GlowPower, num);

                this.m_frame += Time.deltaTime * Random.Range(0.2f, 0.3f);

                yield return new WaitForEndOfFrame();

            }

            yield break;

        }



        // Token: 0x0400009B RID: 155

        private Renderer m_Renderer;



        // Token: 0x0400009C RID: 156

        private Material m_Material;



        // Token: 0x0400009D RID: 157

        public AnimationCurve GlowCurve;



        // Token: 0x0400009E RID: 158

        public float m_frame;

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000024 RID: 36

    public class SimpleScript : MonoBehaviour

    {

        // Token: 0x06000074 RID: 116 RVA: 0x0000465C File Offset: 0x0000285C

        private void Start()

        {

            this.m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();

            this.m_textMeshPro.autoSizeTextContainer = true;

            this.m_textMeshPro.fontSize = 48f;

            this.m_textMeshPro.alignment = TextAlignmentOptions.Center;

            this.m_textMeshPro.textWrappingMode = TextWrappingModes.NoWrap;

        }



        // Token: 0x06000075 RID: 117 RVA: 0x000046B2 File Offset: 0x000028B2

        private void Update()

        {

            this.m_textMeshPro.SetText("The <#0050FF>count is: </color>{0:2}", this.m_frame % 1000f);

            this.m_frame += 1f * Time.deltaTime;

        }



        // Token: 0x0400009F RID: 159

        private TextMeshPro m_textMeshPro;



        // Token: 0x040000A0 RID: 160

        private const string label = "The <#0050FF>count is: </color>{0:2}";



        // Token: 0x040000A1 RID: 161

        private float m_frame;

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000025 RID: 37

    public class SkewTextExample : MonoBehaviour

    {

        // Token: 0x06000077 RID: 119 RVA: 0x000046F0 File Offset: 0x000028F0

        private void Awake()

        {

            this.m_TextComponent = base.gameObject.GetComponent<TMP_Text>();

        }



        // Token: 0x06000078 RID: 120 RVA: 0x00004703 File Offset: 0x00002903

        private void Start()

        {

            base.StartCoroutine(this.WarpText());

        }



        // Token: 0x06000079 RID: 121 RVA: 0x00004712 File Offset: 0x00002912

        private AnimationCurve CopyAnimationCurve(AnimationCurve curve)

        {

            return new AnimationCurve

            {

                keys = curve.keys

            };

        }



        // Token: 0x0600007A RID: 122 RVA: 0x00004725 File Offset: 0x00002925

        private IEnumerator WarpText()

        {

            this.VertexCurve.preWrapMode = WrapMode.Once;

            this.VertexCurve.postWrapMode = WrapMode.Once;

            this.m_TextComponent.havePropertiesChanged = true;

            this.CurveScale *= 10f;

            float old_CurveScale = this.CurveScale;

            float old_ShearValue = this.ShearAmount;

            AnimationCurve old_curve = this.CopyAnimationCurve(this.VertexCurve);

            for (;;)

            {

                if (!this.m_TextComponent.havePropertiesChanged && old_CurveScale == this.CurveScale && old_curve.keys[1].value == this.VertexCurve.keys[1].value && old_ShearValue == this.ShearAmount)

                {

                    yield return null;

                }

                else

                {

                    old_CurveScale = this.CurveScale;

                    old_curve = this.CopyAnimationCurve(this.VertexCurve);

                    old_ShearValue = this.ShearAmount;

                    this.m_TextComponent.ForceMeshUpdate(false, false);

                    TMP_TextInfo textInfo = this.m_TextComponent.textInfo;

                    int characterCount = textInfo.characterCount;

                    if (characterCount != 0)

                    {

                        float x = this.m_TextComponent.bounds.min.x;

                        float x2 = this.m_TextComponent.bounds.max.x;

                        for (int i = 0; i < characterCount; i++)

                        {

                            if (textInfo.characterInfo[i].isVisible)

                            {

                                int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                                int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;

                                Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;

                                Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);

                                vertices[vertexIndex] += -vector;

                                vertices[vertexIndex + 1] += -vector;

                                vertices[vertexIndex + 2] += -vector;

                                vertices[vertexIndex + 3] += -vector;

                                float num = this.ShearAmount * 0.01f;

                                Vector3 vector2 = new Vector3(num * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0f, 0f);

                                Vector3 vector3 = new Vector3(num * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0f, 0f);

                                vertices[vertexIndex] += -vector3;

                                vertices[vertexIndex + 1] += vector2;

                                vertices[vertexIndex + 2] += vector2;

                                vertices[vertexIndex + 3] += -vector3;

                                float num2 = (vector.x - x) / (x2 - x);

                                float num3 = num2 + 0.0001f;

                                float num4 = this.VertexCurve.Evaluate(num2) * this.CurveScale;

                                float num5 = this.VertexCurve.Evaluate(num3) * this.CurveScale;

                                Vector3 vector4 = new Vector3(1f, 0f, 0f);

                                Vector3 vector5 = new Vector3(num3 * (x2 - x) + x, num5) - new Vector3(vector.x, num4);

                                float num6 = Mathf.Acos(Vector3.Dot(vector4, vector5.normalized)) * 57.29578f;

                                float num7 = ((Vector3.Cross(vector4, vector5).z > 0f) ? num6 : (360f - num6));

                                Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, num4, 0f), Quaternion.Euler(0f, 0f, num7), Vector3.one);

                                vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);

                                vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);

                                vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);

                                vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                                vertices[vertexIndex] += vector;

                                vertices[vertexIndex + 1] += vector;

                                vertices[vertexIndex + 2] += vector;

                                vertices[vertexIndex + 3] += vector;

                            }

                        }

                        this.m_TextComponent.UpdateVertexData();

                        yield return null;

                    }

                }

            }

            yield break;

        }



        // Token: 0x040000A2 RID: 162

        private TMP_Text m_TextComponent;



        // Token: 0x040000A3 RID: 163

        public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe[]

        {

            new Keyframe(0f, 0f),

            new Keyframe(0.25f, 2f),

            new Keyframe(0.5f, 0f),

            new Keyframe(0.75f, 2f),

            new Keyframe(1f, 0f)

        });



        // Token: 0x040000A4 RID: 164

        public float CurveScale = 1f;



        // Token: 0x040000A5 RID: 165

        public float ShearAmount = 1f;

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000026 RID: 38

    public class TeleType : MonoBehaviour

    {

        // Token: 0x0600007C RID: 124 RVA: 0x000047DC File Offset: 0x000029DC

        private void Awake()

        {

            this.m_textMeshPro = base.GetComponent<TMP_Text>();

            this.m_textMeshPro.text = this.label01;

            this.m_textMeshPro.textWrappingMode = TextWrappingModes.Normal;

            this.m_textMeshPro.alignment = TextAlignmentOptions.Top;

        }



        // Token: 0x0600007D RID: 125 RVA: 0x00004817 File Offset: 0x00002A17

        private IEnumerator Start()

        {

            this.m_textMeshPro.ForceMeshUpdate(false, false);

            int totalVisibleCharacters = this.m_textMeshPro.textInfo.characterCount;

            int counter = 0;

            for (;;)

            {

                int num = counter % (totalVisibleCharacters + 1);

                this.m_textMeshPro.maxVisibleCharacters = num;

                if (num >= totalVisibleCharacters)

                {

                    yield return new WaitForSeconds(1f);

                    this.m_textMeshPro.text = this.label02;

                    yield return new WaitForSeconds(1f);

                    this.m_textMeshPro.text = this.label01;

                    yield return new WaitForSeconds(1f);

                }

                counter++;

                yield return new WaitForSeconds(0.05f);

            }

            yield break;

        }



        // Token: 0x040000A6 RID: 166

        private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>";



        // Token: 0x040000A7 RID: 167

        private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>";



        // Token: 0x040000A8 RID: 168

        private TMP_Text m_textMeshPro;

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000027 RID: 39

    public class TextConsoleSimulator : MonoBehaviour

    {

        // Token: 0x0600007F RID: 127 RVA: 0x00004844 File Offset: 0x00002A44

        private void Awake()

        {

            this.m_TextComponent = base.gameObject.GetComponent<TMP_Text>();

        }



        // Token: 0x06000080 RID: 128 RVA: 0x00004857 File Offset: 0x00002A57

        private void Start()

        {

            base.StartCoroutine(this.RevealCharacters(this.m_TextComponent));

        }



        // Token: 0x06000081 RID: 129 RVA: 0x0000486C File Offset: 0x00002A6C

        private void OnEnable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x06000082 RID: 130 RVA: 0x00004884 File Offset: 0x00002A84

        private void OnDisable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x06000083 RID: 131 RVA: 0x0000489C File Offset: 0x00002A9C

        private void ON_TEXT_CHANGED(Object obj)

        {

            this.hasTextChanged = true;

        }



        // Token: 0x06000084 RID: 132 RVA: 0x000048A5 File Offset: 0x00002AA5

        private IEnumerator RevealCharacters(TMP_Text textComponent)

        {

            textComponent.ForceMeshUpdate(false, false);

            TMP_TextInfo textInfo = textComponent.textInfo;

            int totalVisibleCharacters = textInfo.characterCount;

            int visibleCount = 0;

            for (;;)

            {

                if (this.hasTextChanged)

                {

                    totalVisibleCharacters = textInfo.characterCount;

                    this.hasTextChanged = false;

                }

                if (visibleCount > totalVisibleCharacters)

                {

                    yield return new WaitForSeconds(1f);

                    visibleCount = 0;

                }

                textComponent.maxVisibleCharacters = visibleCount;

                visibleCount++;

                yield return null;

            }

            yield break;

        }



        // Token: 0x06000085 RID: 133 RVA: 0x000048BB File Offset: 0x00002ABB

        private IEnumerator RevealWords(TMP_Text textComponent)

        {

            textComponent.ForceMeshUpdate(false, false);

            int totalWordCount = textComponent.textInfo.wordCount;

            int totalVisibleCharacters = textComponent.textInfo.characterCount;

            int counter = 0;

            int visibleCount = 0;

            for (;;)

            {

                int num = counter % (totalWordCount + 1);

                if (num == 0)

                {

                    visibleCount = 0;

                }

                else if (num < totalWordCount)

                {

                    visibleCount = textComponent.textInfo.wordInfo[num - 1].lastCharacterIndex + 1;

                }

                else if (num == totalWordCount)

                {

                    visibleCount = totalVisibleCharacters;

                }

                textComponent.maxVisibleCharacters = visibleCount;

                if (visibleCount >= totalVisibleCharacters)

                {

                    yield return new WaitForSeconds(1f);

                }

                counter++;

                yield return new WaitForSeconds(0.1f);

            }

            yield break;

        }



        // Token: 0x040000A9 RID: 169

        private TMP_Text m_TextComponent;



        // Token: 0x040000AA RID: 170

        private bool hasTextChanged;

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000028 RID: 40

    public class TextMeshProFloatingText : MonoBehaviour

    {

        // Token: 0x06000087 RID: 135 RVA: 0x000048D2 File Offset: 0x00002AD2

        private void Awake()

        {

            this.m_transform = base.transform;

            this.m_floatingText = new GameObject(base.name + " floating text");

            this.m_cameraTransform = Camera.main.transform;

        }



        // Token: 0x06000088 RID: 136 RVA: 0x0000490C File Offset: 0x00002B0C

        private void Start()

        {

            if (this.SpawnType == 0)

            {

                this.m_textMeshPro = this.m_floatingText.AddComponent<TextMeshPro>();

                this.m_textMeshPro.rectTransform.sizeDelta = new Vector2(3f, 3f);

                this.m_floatingText_Transform = this.m_floatingText.transform;

                this.m_floatingText_Transform.position = this.m_transform.position + new Vector3(0f, 15f, 0f);

                this.m_textMeshPro.alignment = TextAlignmentOptions.Center;

                this.m_textMeshPro.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);

                this.m_textMeshPro.fontSize = 24f;

                this.m_textMeshPro.fontFeatures.Clear();

                this.m_textMeshPro.text = string.Empty;

                this.m_textMeshPro.isTextObjectScaleStatic = this.IsTextObjectScaleStatic;

                base.StartCoroutine(this.DisplayTextMeshProFloatingText());

                return;

            }

            if (this.SpawnType == 1)

            {

                this.m_floatingText_Transform = this.m_floatingText.transform;

                this.m_floatingText_Transform.position = this.m_transform.position + new Vector3(0f, 15f, 0f);

                this.m_textMesh = this.m_floatingText.AddComponent<TextMesh>();

                this.m_textMesh.font = Resources.Load<Font>("Fonts/ARIAL");

                this.m_textMesh.GetComponent<Renderer>().sharedMaterial = this.m_textMesh.font.material;

                this.m_textMesh.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);

                this.m_textMesh.anchor = TextAnchor.LowerCenter;

                this.m_textMesh.fontSize = 24;

                base.StartCoroutine(this.DisplayTextMeshFloatingText());

                return;

            }

            int spawnType = this.SpawnType;

        }



        // Token: 0x06000089 RID: 137 RVA: 0x00004B31 File Offset: 0x00002D31

        public IEnumerator DisplayTextMeshProFloatingText()

        {

            float CountDuration = 2f;

            float starting_Count = Random.Range(5f, 20f);

            float current_Count = starting_Count;

            Vector3 start_pos = this.m_floatingText_Transform.position;

            Color32 start_color = this.m_textMeshPro.color;

            float alpha = 255f;

            float fadeDuration = 3f / starting_Count * CountDuration;

            while (current_Count > 0f)

            {

                current_Count -= Time.deltaTime / CountDuration * starting_Count;

                if (current_Count <= 3f)

                {

                    alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);

                }

                int num = (int)current_Count;

                this.m_textMeshPro.text = num.ToString();

                this.m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);

                this.m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);

                if (!this.lastPOS.Compare(this.m_cameraTransform.position, 1000) || !this.lastRotation.Compare(this.m_cameraTransform.rotation, 1000))

                {

                    this.lastPOS = this.m_cameraTransform.position;

                    this.lastRotation = this.m_cameraTransform.rotation;

                    this.m_floatingText_Transform.rotation = this.lastRotation;

                    Vector3 vector = this.m_transform.position - this.lastPOS;

                    this.m_transform.forward = new Vector3(vector.x, 0f, vector.z);

                }

                yield return TextMeshProFloatingText.k_WaitForEndOfFrame;

            }

            yield return TextMeshProFloatingText.k_WaitForSecondsRandom[Random.Range(0, 19)];

            this.m_floatingText_Transform.position = start_pos;

            base.StartCoroutine(this.DisplayTextMeshProFloatingText());

            yield break;

        }



        // Token: 0x0600008A RID: 138 RVA: 0x00004B40 File Offset: 0x00002D40

        public IEnumerator DisplayTextMeshFloatingText()

        {

            float CountDuration = 2f;

            float starting_Count = Random.Range(5f, 20f);

            float current_Count = starting_Count;

            Vector3 start_pos = this.m_floatingText_Transform.position;

            Color32 start_color = this.m_textMesh.color;

            float alpha = 255f;

            float fadeDuration = 3f / starting_Count * CountDuration;

            while (current_Count > 0f)

            {

                current_Count -= Time.deltaTime / CountDuration * starting_Count;

                if (current_Count <= 3f)

                {

                    alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);

                }

                int num = (int)current_Count;

                this.m_textMesh.text = num.ToString();

                this.m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);

                this.m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);

                if (!this.lastPOS.Compare(this.m_cameraTransform.position, 1000) || !this.lastRotation.Compare(this.m_cameraTransform.rotation, 1000))

                {

                    this.lastPOS = this.m_cameraTransform.position;

                    this.lastRotation = this.m_cameraTransform.rotation;

                    this.m_floatingText_Transform.rotation = this.lastRotation;

                    Vector3 vector = this.m_transform.position - this.lastPOS;

                    this.m_transform.forward = new Vector3(vector.x, 0f, vector.z);

                }

                yield return TextMeshProFloatingText.k_WaitForEndOfFrame;

            }

            yield return TextMeshProFloatingText.k_WaitForSecondsRandom[Random.Range(0, 20)];

            this.m_floatingText_Transform.position = start_pos;

            base.StartCoroutine(this.DisplayTextMeshFloatingText());

            yield break;

        }



        // Token: 0x040000AB RID: 171

        public Font TheFont;



        // Token: 0x040000AC RID: 172

        private GameObject m_floatingText;



        // Token: 0x040000AD RID: 173

        private TextMeshPro m_textMeshPro;



        // Token: 0x040000AE RID: 174

        private TextMesh m_textMesh;



        // Token: 0x040000AF RID: 175

        private Transform m_transform;



        // Token: 0x040000B0 RID: 176

        private Transform m_floatingText_Transform;



        // Token: 0x040000B1 RID: 177

        private Transform m_cameraTransform;



        // Token: 0x040000B2 RID: 178

        private Vector3 lastPOS = Vector3.zero;



        // Token: 0x040000B3 RID: 179

        private Quaternion lastRotation = Quaternion.identity;



        // Token: 0x040000B4 RID: 180

        public int SpawnType;



        // Token: 0x040000B5 RID: 181

        public bool IsTextObjectScaleStatic;



        // Token: 0x040000B6 RID: 182

        private static WaitForEndOfFrame k_WaitForEndOfFrame = new WaitForEndOfFrame();



        // Token: 0x040000B7 RID: 183

        private static WaitForSeconds[] k_WaitForSecondsRandom = new WaitForSeconds[]

        {

            new WaitForSeconds(0.05f),

            new WaitForSeconds(0.1f),

            new WaitForSeconds(0.15f),

            new WaitForSeconds(0.2f),

            new WaitForSeconds(0.25f),

            new WaitForSeconds(0.3f),

            new WaitForSeconds(0.35f),

            new WaitForSeconds(0.4f),

            new WaitForSeconds(0.45f),

            new WaitForSeconds(0.5f),

            new WaitForSeconds(0.55f),

            new WaitForSeconds(0.6f),

            new WaitForSeconds(0.65f),

            new WaitForSeconds(0.7f),

            new WaitForSeconds(0.75f),

            new WaitForSeconds(0.8f),

            new WaitForSeconds(0.85f),

            new WaitForSeconds(0.9f),

            new WaitForSeconds(0.95f),

            new WaitForSeconds(1f)

        };

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000029 RID: 41

    public class TextMeshSpawner : MonoBehaviour

    {

        // Token: 0x0600008D RID: 141 RVA: 0x00004CA2 File Offset: 0x00002EA2

        private void Awake()

        {

        }



        // Token: 0x0600008E RID: 142 RVA: 0x00004CA4 File Offset: 0x00002EA4

        private void Start()

        {

            for (int i = 0; i < this.NumberOfNPC; i++)

            {

                if (this.SpawnType == 0)

                {

                    GameObject gameObject = new GameObject();

                    gameObject.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));

                    TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();

                    textMeshPro.fontSize = 96f;

                    textMeshPro.text = "!";

                    textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);

                    this.floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();

                    this.floatingText_Script.SpawnType = 0;

                }

                else

                {

                    GameObject gameObject2 = new GameObject();

                    gameObject2.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));

                    TextMesh textMesh = gameObject2.AddComponent<TextMesh>();

                    textMesh.GetComponent<Renderer>().sharedMaterial = this.TheFont.material;

                    textMesh.font = this.TheFont;

                    textMesh.anchor = TextAnchor.LowerCenter;

                    textMesh.fontSize = 96;

                    textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);

                    textMesh.text = "!";

                    this.floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();

                    this.floatingText_Script.SpawnType = 1;

                }

            }

        }



        // Token: 0x040000B8 RID: 184

        public int SpawnType;



        // Token: 0x040000B9 RID: 185

        public int NumberOfNPC = 12;



        // Token: 0x040000BA RID: 186

        public Font TheFont;



        // Token: 0x040000BB RID: 187

        private TextMeshProFloatingText floatingText_Script;

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x0200002A RID: 42

    public class TMPro_InstructionOverlay : MonoBehaviour

    {

        // Token: 0x06000090 RID: 144 RVA: 0x00004E28 File Offset: 0x00003028

        private void Awake()

        {

            if (!base.enabled)

            {

                return;

            }

            this.m_camera = Camera.main;

            GameObject gameObject = new GameObject("Frame Counter");

            this.m_frameCounter_transform = gameObject.transform;

            this.m_frameCounter_transform.parent = this.m_camera.transform;

            this.m_frameCounter_transform.localRotation = Quaternion.identity;

            this.m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();

            this.m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");

            this.m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");

            this.m_TextMeshPro.fontSize = 30f;

            this.m_TextMeshPro.isOverlay = true;

            this.m_textContainer = gameObject.GetComponent<TextContainer>();

            this.Set_FrameCounter_Position(this.AnchorPosition);

            this.m_TextMeshPro.text = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";

        }



        // Token: 0x06000091 RID: 145 RVA: 0x00004F00 File Offset: 0x00003100

        private void Set_FrameCounter_Position(TMPro_InstructionOverlay.FpsCounterAnchorPositions anchor_position)

        {

            switch (anchor_position)

            {

            case TMPro_InstructionOverlay.FpsCounterAnchorPositions.TopLeft:

                this.m_textContainer.anchorPosition = TextContainerAnchors.TopLeft;

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));

                return;

            case TMPro_InstructionOverlay.FpsCounterAnchorPositions.BottomLeft:

                this.m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft;

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));

                return;

            case TMPro_InstructionOverlay.FpsCounterAnchorPositions.TopRight:

                this.m_textContainer.anchorPosition = TextContainerAnchors.TopRight;

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));

                return;

            case TMPro_InstructionOverlay.FpsCounterAnchorPositions.BottomRight:

                this.m_textContainer.anchorPosition = TextContainerAnchors.BottomRight;

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));

                return;

            default:

                return;

            }

        }



        // Token: 0x040000BC RID: 188

        public TMPro_InstructionOverlay.FpsCounterAnchorPositions AnchorPosition = TMPro_InstructionOverlay.FpsCounterAnchorPositions.BottomLeft;



        // Token: 0x040000BD RID: 189

        private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";



        // Token: 0x040000BE RID: 190

        private TextMeshPro m_TextMeshPro;



        // Token: 0x040000BF RID: 191

        private TextContainer m_textContainer;



        // Token: 0x040000C0 RID: 192

        private Transform m_frameCounter_transform;



        // Token: 0x040000C1 RID: 193

        private Camera m_camera;



        // Token: 0x0200004D RID: 77

        public enum FpsCounterAnchorPositions

        {

            // Token: 0x04000162 RID: 354

            TopLeft,

            // Token: 0x04000163 RID: 355

            BottomLeft,

            // Token: 0x04000164 RID: 356

            TopRight,

            // Token: 0x04000165 RID: 357

            BottomRight

        }

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x0200002B RID: 43

    public class TMP_ExampleScript_01 : MonoBehaviour

    {

        // Token: 0x06000093 RID: 147 RVA: 0x00005010 File Offset: 0x00003210

        private void Awake()

        {

            if (this.ObjectType == TMP_ExampleScript_01.objectType.TextMeshPro)

            {

                this.m_text = base.GetComponent<TextMeshPro>() ?? base.gameObject.AddComponent<TextMeshPro>();

            }

            else

            {

                this.m_text = base.GetComponent<TextMeshProUGUI>() ?? base.gameObject.AddComponent<TextMeshProUGUI>();

            }

            this.m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF");

            this.m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow");

            this.m_text.fontSize = 120f;

            this.m_text.text = "A <#0080ff>simple</color> line of text.";

            Vector2 preferredValues = this.m_text.GetPreferredValues(float.PositiveInfinity, float.PositiveInfinity);

            this.m_text.rectTransform.sizeDelta = new Vector2(preferredValues.x, preferredValues.y);

        }



        // Token: 0x06000094 RID: 148 RVA: 0x000050DE File Offset: 0x000032DE

        private void Update()

        {

            if (!this.isStatic)

            {

                this.m_text.SetText("The count is <#0080ff>{0}</color>", (float)(this.count % 1000));

                this.count++;

            }

        }



        // Token: 0x040000C2 RID: 194

        public TMP_ExampleScript_01.objectType ObjectType;



        // Token: 0x040000C3 RID: 195

        public bool isStatic;



        // Token: 0x040000C4 RID: 196

        private TMP_Text m_text;



        // Token: 0x040000C5 RID: 197

        private const string k_label = "The count is <#0080ff>{0}</color>";



        // Token: 0x040000C6 RID: 198

        private int count;



        // Token: 0x0200004E RID: 78

        public enum objectType

        {

            // Token: 0x04000167 RID: 359

            TextMeshPro,

            // Token: 0x04000168 RID: 360

            TextMeshProUGUI

        }

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x0200002C RID: 44

    public class TMP_FrameRateCounter : MonoBehaviour

    {

        // Token: 0x06000096 RID: 150 RVA: 0x0000511C File Offset: 0x0000331C

        private void Awake()

        {

            if (!base.enabled)

            {

                return;

            }

            this.m_camera = Camera.main;

            Application.targetFrameRate = 9999;

            GameObject gameObject = new GameObject("Frame Counter");

            this.m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();

            this.m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");

            this.m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");

            this.m_frameCounter_transform = gameObject.transform;

            this.m_frameCounter_transform.SetParent(this.m_camera.transform);

            this.m_frameCounter_transform.localRotation = Quaternion.identity;

            this.m_TextMeshPro.textWrappingMode = TextWrappingModes.NoWrap;

            this.m_TextMeshPro.fontSize = 24f;

            this.Set_FrameCounter_Position(this.AnchorPosition);

            this.last_AnchorPosition = this.AnchorPosition;

        }



        // Token: 0x06000097 RID: 151 RVA: 0x000051EE File Offset: 0x000033EE

        private void Start()

        {

            this.m_LastInterval = Time.realtimeSinceStartup;

            this.m_Frames = 0;

        }



        // Token: 0x06000098 RID: 152 RVA: 0x00005204 File Offset: 0x00003404

        private void Update()

        {

            if (this.AnchorPosition != this.last_AnchorPosition)

            {

                this.Set_FrameCounter_Position(this.AnchorPosition);

            }

            this.last_AnchorPosition = this.AnchorPosition;

            this.m_Frames++;

            float realtimeSinceStartup = Time.realtimeSinceStartup;

            if (realtimeSinceStartup > this.m_LastInterval + this.UpdateInterval)

            {

                float num = (float)this.m_Frames / (realtimeSinceStartup - this.m_LastInterval);

                float num2 = 1000f / Mathf.Max(num, 1E-05f);

                if (num < 30f)

                {

                    this.htmlColorTag = "<color=yellow>";

                }

                else if (num < 10f)

                {

                    this.htmlColorTag = "<color=red>";

                }

                else

                {

                    this.htmlColorTag = "<color=green>";

                }

                this.m_TextMeshPro.SetText(this.htmlColorTag + "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS", num, num2);

                this.m_Frames = 0;

                this.m_LastInterval = realtimeSinceStartup;

            }

        }



        // Token: 0x06000099 RID: 153 RVA: 0x000052E4 File Offset: 0x000034E4

        private void Set_FrameCounter_Position(TMP_FrameRateCounter.FpsCounterAnchorPositions anchor_position)

        {

            this.m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f);

            switch (anchor_position)

            {

            case TMP_FrameRateCounter.FpsCounterAnchorPositions.TopLeft:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;

                this.m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 1f);

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));

                return;

            case TMP_FrameRateCounter.FpsCounterAnchorPositions.BottomLeft:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;

                this.m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 0f);

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));

                return;

            case TMP_FrameRateCounter.FpsCounterAnchorPositions.TopRight:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;

                this.m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 1f);

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));

                return;

            case TMP_FrameRateCounter.FpsCounterAnchorPositions.BottomRight:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;

                this.m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 0f);

                this.m_frameCounter_transform.position = this.m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));

                return;

            default:

                return;

            }

        }



        // Token: 0x040000C7 RID: 199

        public float UpdateInterval = 5f;



        // Token: 0x040000C8 RID: 200

        private float m_LastInterval;



        // Token: 0x040000C9 RID: 201

        private int m_Frames;



        // Token: 0x040000CA RID: 202

        public TMP_FrameRateCounter.FpsCounterAnchorPositions AnchorPosition = TMP_FrameRateCounter.FpsCounterAnchorPositions.TopRight;



        // Token: 0x040000CB RID: 203

        private string htmlColorTag;



        // Token: 0x040000CC RID: 204

        private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";



        // Token: 0x040000CD RID: 205

        private TextMeshPro m_TextMeshPro;



        // Token: 0x040000CE RID: 206

        private Transform m_frameCounter_transform;



        // Token: 0x040000CF RID: 207

        private Camera m_camera;



        // Token: 0x040000D0 RID: 208

        private TMP_FrameRateCounter.FpsCounterAnchorPositions last_AnchorPosition;



        // Token: 0x0200004F RID: 79

        public enum FpsCounterAnchorPositions

        {

            // Token: 0x0400016A RID: 362

            TopLeft,

            // Token: 0x0400016B RID: 363

            BottomLeft,

            // Token: 0x0400016C RID: 364

            TopRight,

            // Token: 0x0400016D RID: 365

            BottomRight

        }

    }

}



using System;

using UnityEngine;

using UnityEngine.Events;



namespace TMPro.Examples

{

    // Token: 0x0200002D RID: 45

    public class TMP_TextEventCheck : MonoBehaviour

    {

        // Token: 0x0600009B RID: 155 RVA: 0x000054B0 File Offset: 0x000036B0

        private void OnEnable()

        {

            if (this.TextEventHandler != null)

            {

                this.m_TextComponent = this.TextEventHandler.GetComponent<TMP_Text>();

                this.TextEventHandler.onCharacterSelection.AddListener(new UnityAction<char, int>(this.OnCharacterSelection));

                this.TextEventHandler.onSpriteSelection.AddListener(new UnityAction<char, int>(this.OnSpriteSelection));

                this.TextEventHandler.onWordSelection.AddListener(new UnityAction<string, int, int>(this.OnWordSelection));

                this.TextEventHandler.onLineSelection.AddListener(new UnityAction<string, int, int>(this.OnLineSelection));

                this.TextEventHandler.onLinkSelection.AddListener(new UnityAction<string, string, int>(this.OnLinkSelection));

            }

        }



        // Token: 0x0600009C RID: 156 RVA: 0x0000556C File Offset: 0x0000376C

        private void OnDisable()

        {

            if (this.TextEventHandler != null)

            {

                this.TextEventHandler.onCharacterSelection.RemoveListener(new UnityAction<char, int>(this.OnCharacterSelection));

                this.TextEventHandler.onSpriteSelection.RemoveListener(new UnityAction<char, int>(this.OnSpriteSelection));

                this.TextEventHandler.onWordSelection.RemoveListener(new UnityAction<string, int, int>(this.OnWordSelection));

                this.TextEventHandler.onLineSelection.RemoveListener(new UnityAction<string, int, int>(this.OnLineSelection));

                this.TextEventHandler.onLinkSelection.RemoveListener(new UnityAction<string, string, int>(this.OnLinkSelection));

            }

        }



        // Token: 0x0600009D RID: 157 RVA: 0x00005616 File Offset: 0x00003816

        private void OnCharacterSelection(char c, int index)

        {

            Debug.Log(string.Concat(new string[]

            {

                "Character [",

                c.ToString(),

                "] at Index: ",

                index.ToString(),

                " has been selected."

            }));

        }



        // Token: 0x0600009E RID: 158 RVA: 0x00005654 File Offset: 0x00003854

        private void OnSpriteSelection(char c, int index)

        {

            Debug.Log(string.Concat(new string[]

            {

                "Sprite [",

                c.ToString(),

                "] at Index: ",

                index.ToString(),

                " has been selected."

            }));

        }



        // Token: 0x0600009F RID: 159 RVA: 0x00005694 File Offset: 0x00003894

        private void OnWordSelection(string word, int firstCharacterIndex, int length)

        {

            Debug.Log(string.Concat(new string[]

            {

                "Word [",

                word,

                "] with first character index of ",

                firstCharacterIndex.ToString(),

                " and length of ",

                length.ToString(),

                " has been selected."

            }));

        }



        // Token: 0x060000A0 RID: 160 RVA: 0x000056EC File Offset: 0x000038EC

        private void OnLineSelection(string lineText, int firstCharacterIndex, int length)

        {

            Debug.Log(string.Concat(new string[]

            {

                "Line [",

                lineText,

                "] with first character index of ",

                firstCharacterIndex.ToString(),

                " and length of ",

                length.ToString(),

                " has been selected."

            }));

        }



        // Token: 0x060000A1 RID: 161 RVA: 0x00005744 File Offset: 0x00003944

        private void OnLinkSelection(string linkID, string linkText, int linkIndex)

        {

            if (this.m_TextComponent != null)

            {

                TMP_LinkInfo[] linkInfo = this.m_TextComponent.textInfo.linkInfo;

            }

            Debug.Log(string.Concat(new string[]

            {

                "Link Index: ",

                linkIndex.ToString(),

                " with ID [",

                linkID,

                "] and Text \"",

                linkText,

                "\" has been selected."

            }));

        }



        // Token: 0x040000D1 RID: 209

        public TMP_TextEventHandler TextEventHandler;



        // Token: 0x040000D2 RID: 210

        private TMP_Text m_TextComponent;

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x0200002E RID: 46

    public class TMP_TextInfoDebugTool : MonoBehaviour

    {

    }

}



using System;

using UnityEngine;

using UnityEngine.EventSystems;



namespace TMPro.Examples

{

    // Token: 0x0200002F RID: 47

    public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler

    {

        // Token: 0x060000A4 RID: 164 RVA: 0x000057C8 File Offset: 0x000039C8

        private void Awake()

        {

            this.m_TextMeshPro = base.gameObject.GetComponent<TextMeshPro>();

            this.m_Camera = Camera.main;

            this.m_TextMeshPro.ForceMeshUpdate(false, false);

        }



        // Token: 0x060000A5 RID: 165 RVA: 0x000057F4 File Offset: 0x000039F4

        private void LateUpdate()

        {

            this.m_isHoveringObject = false;

            if (TMP_TextUtilities.IsIntersectingRectTransform(this.m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main))

            {

                this.m_isHoveringObject = true;

            }

            if (this.m_isHoveringObject)

            {

                int num = TMP_TextUtilities.FindIntersectingCharacter(this.m_TextMeshPro, Input.mousePosition, Camera.main, true);

                if (num != -1 && num != this.m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))

                {

                    this.m_lastCharIndex = num;

                    int materialReferenceIndex = this.m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;

                    int vertexIndex = this.m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;

                    Color32 color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);

                    Color32[] colors = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;

                    colors[vertexIndex] = color;

                    colors[vertexIndex + 1] = color;

                    colors[vertexIndex + 2] = color;

                    colors[vertexIndex + 3] = color;

                    this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].mesh.colors32 = colors;

                }

                int num2 = TMP_TextUtilities.FindIntersectingLink(this.m_TextMeshPro, Input.mousePosition, this.m_Camera);

                if ((num2 == -1 && this.m_selectedLink != -1) || num2 != this.m_selectedLink)

                {

                    this.m_selectedLink = -1;

                }

                if (num2 != -1 && num2 != this.m_selectedLink)

                {

                    this.m_selectedLink = num2;

                    TMP_LinkInfo tmp_LinkInfo = this.m_TextMeshPro.textInfo.linkInfo[num2];

                    Vector3 vector;

                    RectTransformUtility.ScreenPointToWorldPointInRectangle(this.m_TextMeshPro.rectTransform, Input.mousePosition, this.m_Camera, out vector);

                    string linkID = tmp_LinkInfo.GetLinkID();

                    if (!(linkID == "id_01"))

                    {

                        linkID == "id_02";

                    }

                }

                int num3 = TMP_TextUtilities.FindIntersectingWord(this.m_TextMeshPro, Input.mousePosition, Camera.main);

                if (num3 != -1 && num3 != this.m_lastWordIndex)

                {

                    this.m_lastWordIndex = num3;

                    TMP_WordInfo tmp_WordInfo = this.m_TextMeshPro.textInfo.wordInfo[num3];

                    Vector3 vector2 = this.m_TextMeshPro.transform.TransformPoint(this.m_TextMeshPro.textInfo.characterInfo[tmp_WordInfo.firstCharacterIndex].bottomLeft);

                    vector2 = Camera.main.WorldToScreenPoint(vector2);

                    Color32[] colors2 = this.m_TextMeshPro.textInfo.meshInfo[0].colors32;

                    Color32 color2 = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);

                    for (int i = 0; i < tmp_WordInfo.characterCount; i++)

                    {

                        int vertexIndex2 = this.m_TextMeshPro.textInfo.characterInfo[tmp_WordInfo.firstCharacterIndex + i].vertexIndex;

                        colors2[vertexIndex2] = color2;

                        colors2[vertexIndex2 + 1] = color2;

                        colors2[vertexIndex2 + 2] = color2;

                        colors2[vertexIndex2 + 3] = color2;

                    }

                    this.m_TextMeshPro.mesh.colors32 = colors2;

                }

            }

        }



        // Token: 0x060000A6 RID: 166 RVA: 0x00005B59 File Offset: 0x00003D59

        public void OnPointerEnter(PointerEventData eventData)

        {

            Debug.Log("OnPointerEnter()");

            this.m_isHoveringObject = true;

        }



        // Token: 0x060000A7 RID: 167 RVA: 0x00005B6C File Offset: 0x00003D6C

        public void OnPointerExit(PointerEventData eventData)

        {

            Debug.Log("OnPointerExit()");

            this.m_isHoveringObject = false;

        }



        // Token: 0x040000D3 RID: 211

        private TextMeshPro m_TextMeshPro;



        // Token: 0x040000D4 RID: 212

        private Camera m_Camera;



        // Token: 0x040000D5 RID: 213

        private bool m_isHoveringObject;



        // Token: 0x040000D6 RID: 214

        private int m_selectedLink = -1;



        // Token: 0x040000D7 RID: 215

        private int m_lastCharIndex = -1;



        // Token: 0x040000D8 RID: 216

        private int m_lastWordIndex = -1;

    }

}



using System;

using UnityEngine;

using UnityEngine.EventSystems;



namespace TMPro.Examples

{

    // Token: 0x02000030 RID: 48

    public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler

    {

        // Token: 0x060000A9 RID: 169 RVA: 0x00005B9C File Offset: 0x00003D9C

        private void Awake()

        {

            this.m_TextMeshPro = base.gameObject.GetComponent<TextMeshProUGUI>();

            this.m_Canvas = base.gameObject.GetComponentInParent<Canvas>();

            if (this.m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)

            {

                this.m_Camera = null;

            }

            else

            {

                this.m_Camera = this.m_Canvas.worldCamera;

            }

            this.m_TextPopup_RectTransform = Object.Instantiate<RectTransform>(this.TextPopup_Prefab_01);

            this.m_TextPopup_RectTransform.SetParent(this.m_Canvas.transform, false);

            this.m_TextPopup_TMPComponent = this.m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>();

            this.m_TextPopup_RectTransform.gameObject.SetActive(false);

        }



        // Token: 0x060000AA RID: 170 RVA: 0x00005C3C File Offset: 0x00003E3C

        private void OnEnable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000AB RID: 171 RVA: 0x00005C54 File Offset: 0x00003E54

        private void OnDisable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000AC RID: 172 RVA: 0x00005C6C File Offset: 0x00003E6C

        private void ON_TEXT_CHANGED(Object obj)

        {

            if (obj == this.m_TextMeshPro)

            {

                this.m_cachedMeshInfoVertexData = this.m_TextMeshPro.textInfo.CopyMeshInfoVertexData();

            }

        }



        // Token: 0x060000AD RID: 173 RVA: 0x00005C94 File Offset: 0x00003E94

        private void LateUpdate()

        {

            if (this.isHoveringObject)

            {

                int num = TMP_TextUtilities.FindIntersectingCharacter(this.m_TextMeshPro, Input.mousePosition, this.m_Camera, true);

                if (num == -1 || num != this.m_lastIndex)

                {

                    this.RestoreCachedVertexAttributes(this.m_lastIndex);

                    this.m_lastIndex = -1;

                }

                if (num != -1 && num != this.m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))

                {

                    this.m_lastIndex = num;

                    int materialReferenceIndex = this.m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;

                    int vertexIndex = this.m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;

                    Vector3[] vertices = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;

                    Vector3 vector = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;

                    vertices[vertexIndex] -= vector;

                    vertices[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;

                    vertices[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;

                    vertices[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;

                    float num2 = 1.5f;

                    this.m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * num2);

                    vertices[vertexIndex] = this.m_matrix.MultiplyPoint3x4(vertices[vertexIndex]);

                    vertices[vertexIndex + 1] = this.m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);

                    vertices[vertexIndex + 2] = this.m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);

                    vertices[vertexIndex + 3] = this.m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                    vertices[vertexIndex] += vector;

                    vertices[vertexIndex + 1] = vertices[vertexIndex + 1] + vector;

                    vertices[vertexIndex + 2] = vertices[vertexIndex + 2] + vector;

                    vertices[vertexIndex + 3] = vertices[vertexIndex + 3] + vector;

                    Color32 color = new Color32(byte.MaxValue, byte.MaxValue, 192, byte.MaxValue);

                    Color32[] colors = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;

                    colors[vertexIndex] = color;

                    colors[vertexIndex + 1] = color;

                    colors[vertexIndex + 2] = color;

                    colors[vertexIndex + 3] = color;

                    TMP_MeshInfo tmp_MeshInfo = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex];

                    int num3 = vertices.Length - 4;

                    tmp_MeshInfo.SwapVertexData(vertexIndex, num3);

                    this.m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

                }

                int num4 = TMP_TextUtilities.FindIntersectingWord(this.m_TextMeshPro, Input.mousePosition, this.m_Camera);

                if (this.m_TextPopup_RectTransform != null && this.m_selectedWord != -1 && (num4 == -1 || num4 != this.m_selectedWord))

                {

                    TMP_WordInfo tmp_WordInfo = this.m_TextMeshPro.textInfo.wordInfo[this.m_selectedWord];

                    for (int i = 0; i < tmp_WordInfo.characterCount; i++)

                    {

                        int num5 = tmp_WordInfo.firstCharacterIndex + i;

                        int materialReferenceIndex2 = this.m_TextMeshPro.textInfo.characterInfo[num5].materialReferenceIndex;

                        int vertexIndex2 = this.m_TextMeshPro.textInfo.characterInfo[num5].vertexIndex;

                        Color32[] colors2 = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex2].colors32;

                        Color32 color2 = colors2[vertexIndex2].Tint(1.33333f);

                        colors2[vertexIndex2] = color2;

                        colors2[vertexIndex2 + 1] = color2;

                        colors2[vertexIndex2 + 2] = color2;

                        colors2[vertexIndex2 + 3] = color2;

                    }

                    this.m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

                    this.m_selectedWord = -1;

                }

                if (num4 != -1 && num4 != this.m_selectedWord && !Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift))

                {

                    this.m_selectedWord = num4;

                    TMP_WordInfo tmp_WordInfo2 = this.m_TextMeshPro.textInfo.wordInfo[num4];

                    for (int j = 0; j < tmp_WordInfo2.characterCount; j++)

                    {

                        int num6 = tmp_WordInfo2.firstCharacterIndex + j;

                        int materialReferenceIndex3 = this.m_TextMeshPro.textInfo.characterInfo[num6].materialReferenceIndex;

                        int vertexIndex3 = this.m_TextMeshPro.textInfo.characterInfo[num6].vertexIndex;

                        Color32[] colors3 = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex3].colors32;

                        Color32 color3 = colors3[vertexIndex3].Tint(0.75f);

                        colors3[vertexIndex3] = color3;

                        colors3[vertexIndex3 + 1] = color3;

                        colors3[vertexIndex3 + 2] = color3;

                        colors3[vertexIndex3 + 3] = color3;

                    }

                    this.m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

                }

                int num7 = TMP_TextUtilities.FindIntersectingLink(this.m_TextMeshPro, Input.mousePosition, this.m_Camera);

                if ((num7 == -1 && this.m_selectedLink != -1) || num7 != this.m_selectedLink)

                {

                    this.m_TextPopup_RectTransform.gameObject.SetActive(false);

                    this.m_selectedLink = -1;

                }

                if (num7 != -1 && num7 != this.m_selectedLink)

                {

                    this.m_selectedLink = num7;

                    TMP_LinkInfo tmp_LinkInfo = this.m_TextMeshPro.textInfo.linkInfo[num7];

                    Vector3 vector2;

                    RectTransformUtility.ScreenPointToWorldPointInRectangle(this.m_TextMeshPro.rectTransform, Input.mousePosition, this.m_Camera, out vector2);

                    string linkID = tmp_LinkInfo.GetLinkID();

                    if (linkID == "id_01")

                    {

                        this.m_TextPopup_RectTransform.position = vector2;

                        this.m_TextPopup_RectTransform.gameObject.SetActive(true);

                        this.m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 01";

                        return;

                    }

                    if (!(linkID == "id_02"))

                    {

                        return;

                    }

                    this.m_TextPopup_RectTransform.position = vector2;

                    this.m_TextPopup_RectTransform.gameObject.SetActive(true);

                    this.m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 02";

                    return;

                }

            }

            else if (this.m_lastIndex != -1)

            {

                this.RestoreCachedVertexAttributes(this.m_lastIndex);

                this.m_lastIndex = -1;

            }

        }



        // Token: 0x060000AE RID: 174 RVA: 0x00006358 File Offset: 0x00004558

        public void OnPointerEnter(PointerEventData eventData)

        {

            this.isHoveringObject = true;

        }



        // Token: 0x060000AF RID: 175 RVA: 0x00006361 File Offset: 0x00004561

        public void OnPointerExit(PointerEventData eventData)

        {

            this.isHoveringObject = false;

        }



        // Token: 0x060000B0 RID: 176 RVA: 0x0000636A File Offset: 0x0000456A

        public void OnPointerClick(PointerEventData eventData)

        {

        }



        // Token: 0x060000B1 RID: 177 RVA: 0x0000636C File Offset: 0x0000456C

        public void OnPointerUp(PointerEventData eventData)

        {

        }



        // Token: 0x060000B2 RID: 178 RVA: 0x00006370 File Offset: 0x00004570

        private void RestoreCachedVertexAttributes(int index)

        {

            if (index == -1 || index > this.m_TextMeshPro.textInfo.characterCount - 1)

            {

                return;

            }

            int materialReferenceIndex = this.m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex;

            int vertexIndex = this.m_TextMeshPro.textInfo.characterInfo[index].vertexIndex;

            Vector3[] vertices = this.m_cachedMeshInfoVertexData[materialReferenceIndex].vertices;

            Vector3[] vertices2 = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;

            vertices2[vertexIndex] = vertices[vertexIndex];

            vertices2[vertexIndex + 1] = vertices[vertexIndex + 1];

            vertices2[vertexIndex + 2] = vertices[vertexIndex + 2];

            vertices2[vertexIndex + 3] = vertices[vertexIndex + 3];

            Color32[] colors = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;

            Color32[] array = this.m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;

            colors[vertexIndex] = array[vertexIndex];

            colors[vertexIndex + 1] = array[vertexIndex + 1];

            colors[vertexIndex + 2] = array[vertexIndex + 2];

            colors[vertexIndex + 3] = array[vertexIndex + 3];

            Vector4[] array2 = this.m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;

            Vector4[] uvs = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;

            uvs[vertexIndex] = array2[vertexIndex];

            uvs[vertexIndex + 1] = array2[vertexIndex + 1];

            uvs[vertexIndex + 2] = array2[vertexIndex + 2];

            uvs[vertexIndex + 3] = array2[vertexIndex + 3];

            Vector2[] array3 = this.m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;

            Vector2[] uvs2 = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;

            uvs2[vertexIndex] = array3[vertexIndex];

            uvs2[vertexIndex + 1] = array3[vertexIndex + 1];

            uvs2[vertexIndex + 2] = array3[vertexIndex + 2];

            uvs2[vertexIndex + 3] = array3[vertexIndex + 3];

            int num = (vertices.Length / 4 - 1) * 4;

            vertices2[num] = vertices[num];

            vertices2[num + 1] = vertices[num + 1];

            vertices2[num + 2] = vertices[num + 2];

            vertices2[num + 3] = vertices[num + 3];

            array = this.m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;

            Color32[] colors2 = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;

            colors2[num] = array[num];

            colors2[num + 1] = array[num + 1];

            colors2[num + 2] = array[num + 2];

            colors2[num + 3] = array[num + 3];

            array2 = this.m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;

            Vector4[] uvs3 = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;

            uvs3[num] = array2[num];

            uvs3[num + 1] = array2[num + 1];

            uvs3[num + 2] = array2[num + 2];

            uvs3[num + 3] = array2[num + 3];

            array3 = this.m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;

            Vector2[] uvs4 = this.m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;

            uvs4[num] = array3[num];

            uvs4[num + 1] = array3[num + 1];

            uvs4[num + 2] = array3[num + 2];

            uvs4[num + 3] = array3[num + 3];

            this.m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

        }



        // Token: 0x040000D9 RID: 217

        public RectTransform TextPopup_Prefab_01;



        // Token: 0x040000DA RID: 218

        private RectTransform m_TextPopup_RectTransform;



        // Token: 0x040000DB RID: 219

        private TextMeshProUGUI m_TextPopup_TMPComponent;



        // Token: 0x040000DC RID: 220

        private const string k_LinkText = "You have selected link <#ffff00>";



        // Token: 0x040000DD RID: 221

        private const string k_WordText = "Word Index: <#ffff00>";



        // Token: 0x040000DE RID: 222

        private TextMeshProUGUI m_TextMeshPro;



        // Token: 0x040000DF RID: 223

        private Canvas m_Canvas;



        // Token: 0x040000E0 RID: 224

        private Camera m_Camera;



        // Token: 0x040000E1 RID: 225

        private bool isHoveringObject;



        // Token: 0x040000E2 RID: 226

        private int m_selectedWord = -1;



        // Token: 0x040000E3 RID: 227

        private int m_selectedLink = -1;



        // Token: 0x040000E4 RID: 228

        private int m_lastIndex = -1;



        // Token: 0x040000E5 RID: 229

        private Matrix4x4 m_matrix;



        // Token: 0x040000E6 RID: 230

        private TMP_MeshInfo[] m_cachedMeshInfoVertexData;

    }

}



using System;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000031 RID: 49

    public class TMP_UiFrameRateCounter : MonoBehaviour

    {

        // Token: 0x060000B4 RID: 180 RVA: 0x00006790 File Offset: 0x00004990

        private void Awake()

        {

            if (!base.enabled)

            {

                return;

            }

            Application.targetFrameRate = 1000;

            GameObject gameObject = new GameObject("Frame Counter");

            this.m_frameCounter_transform = gameObject.AddComponent<RectTransform>();

            this.m_frameCounter_transform.SetParent(base.transform, false);

            this.m_TextMeshPro = gameObject.AddComponent<TextMeshProUGUI>();

            this.m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");

            this.m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");

            this.m_TextMeshPro.textWrappingMode = TextWrappingModes.NoWrap;

            this.m_TextMeshPro.fontSize = 36f;

            this.m_TextMeshPro.isOverlay = true;

            this.Set_FrameCounter_Position(this.AnchorPosition);

            this.last_AnchorPosition = this.AnchorPosition;

        }



        // Token: 0x060000B5 RID: 181 RVA: 0x0000684F File Offset: 0x00004A4F

        private void Start()

        {

            this.m_LastInterval = Time.realtimeSinceStartup;

            this.m_Frames = 0;

        }



        // Token: 0x060000B6 RID: 182 RVA: 0x00006864 File Offset: 0x00004A64

        private void Update()

        {

            if (this.AnchorPosition != this.last_AnchorPosition)

            {

                this.Set_FrameCounter_Position(this.AnchorPosition);

            }

            this.last_AnchorPosition = this.AnchorPosition;

            this.m_Frames++;

            float realtimeSinceStartup = Time.realtimeSinceStartup;

            if (realtimeSinceStartup > this.m_LastInterval + this.UpdateInterval)

            {

                float num = (float)this.m_Frames / (realtimeSinceStartup - this.m_LastInterval);

                float num2 = 1000f / Mathf.Max(num, 1E-05f);

                if (num < 30f)

                {

                    this.htmlColorTag = "<color=yellow>";

                }

                else if (num < 10f)

                {

                    this.htmlColorTag = "<color=red>";

                }

                else

                {

                    this.htmlColorTag = "<color=green>";

                }

                this.m_TextMeshPro.SetText(this.htmlColorTag + "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS", num, num2);

                this.m_Frames = 0;

                this.m_LastInterval = realtimeSinceStartup;

            }

        }



        // Token: 0x060000B7 RID: 183 RVA: 0x00006944 File Offset: 0x00004B44

        private void Set_FrameCounter_Position(TMP_UiFrameRateCounter.FpsCounterAnchorPositions anchor_position)

        {

            switch (anchor_position)

            {

            case TMP_UiFrameRateCounter.FpsCounterAnchorPositions.TopLeft:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;

                this.m_frameCounter_transform.pivot = new Vector2(0f, 1f);

                this.m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);

                this.m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);

                this.m_frameCounter_transform.anchoredPosition = new Vector2(0f, 1f);

                return;

            case TMP_UiFrameRateCounter.FpsCounterAnchorPositions.BottomLeft:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;

                this.m_frameCounter_transform.pivot = new Vector2(0f, 0f);

                this.m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);

                this.m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);

                this.m_frameCounter_transform.anchoredPosition = new Vector2(0f, 0f);

                return;

            case TMP_UiFrameRateCounter.FpsCounterAnchorPositions.TopRight:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;

                this.m_frameCounter_transform.pivot = new Vector2(1f, 1f);

                this.m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);

                this.m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);

                this.m_frameCounter_transform.anchoredPosition = new Vector2(1f, 1f);

                return;

            case TMP_UiFrameRateCounter.FpsCounterAnchorPositions.BottomRight:

                this.m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;

                this.m_frameCounter_transform.pivot = new Vector2(1f, 0f);

                this.m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);

                this.m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);

                this.m_frameCounter_transform.anchoredPosition = new Vector2(1f, 0f);

                return;

            default:

                return;

            }

        }



        // Token: 0x040000E7 RID: 231

        public float UpdateInterval = 5f;



        // Token: 0x040000E8 RID: 232

        private float m_LastInterval;



        // Token: 0x040000E9 RID: 233

        private int m_Frames;



        // Token: 0x040000EA RID: 234

        public TMP_UiFrameRateCounter.FpsCounterAnchorPositions AnchorPosition = TMP_UiFrameRateCounter.FpsCounterAnchorPositions.TopRight;



        // Token: 0x040000EB RID: 235

        private string htmlColorTag;



        // Token: 0x040000EC RID: 236

        private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";



        // Token: 0x040000ED RID: 237

        private TextMeshProUGUI m_TextMeshPro;



        // Token: 0x040000EE RID: 238

        private RectTransform m_frameCounter_transform;



        // Token: 0x040000EF RID: 239

        private TMP_UiFrameRateCounter.FpsCounterAnchorPositions last_AnchorPosition;



        // Token: 0x02000050 RID: 80

        public enum FpsCounterAnchorPositions

        {

            // Token: 0x0400016F RID: 367

            TopLeft,

            // Token: 0x04000170 RID: 368

            BottomLeft,

            // Token: 0x04000171 RID: 369

            TopRight,

            // Token: 0x04000172 RID: 370

            BottomRight

        }

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000032 RID: 50

    public class VertexColorCycler : MonoBehaviour

    {

        // Token: 0x060000B9 RID: 185 RVA: 0x00006B65 File Offset: 0x00004D65

        private void Awake()

        {

            this.m_TextComponent = base.GetComponent<TMP_Text>();

        }



        // Token: 0x060000BA RID: 186 RVA: 0x00006B73 File Offset: 0x00004D73

        private void Start()

        {

            base.StartCoroutine(this.AnimateVertexColors());

        }



        // Token: 0x060000BB RID: 187 RVA: 0x00006B82 File Offset: 0x00004D82

        private IEnumerator AnimateVertexColors()

        {

            this.m_TextComponent.ForceMeshUpdate(false, false);

            TMP_TextInfo textInfo = this.m_TextComponent.textInfo;

            int currentCharacter = 0;

            Color32 color = this.m_TextComponent.color;

            for (;;)

            {

                int characterCount = textInfo.characterCount;

                if (characterCount == 0)

                {

                    yield return new WaitForSeconds(0.25f);

                }

                else

                {

                    int materialReferenceIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex;

                    Color32[] colors = textInfo.meshInfo[materialReferenceIndex].colors32;

                    int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex;

                    if (textInfo.characterInfo[currentCharacter].isVisible)

                    {

                        color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);

                        colors[vertexIndex] = color;

                        colors[vertexIndex + 1] = color;

                        colors[vertexIndex + 2] = color;

                        colors[vertexIndex + 3] = color;

                        this.m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);

                    }

                    currentCharacter = (currentCharacter + 1) % characterCount;

                    yield return new WaitForSeconds(0.05f);

                }

            }

            yield break;

        }



        // Token: 0x040000F0 RID: 240

        private TMP_Text m_TextComponent;

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000033 RID: 51

    public class VertexJitter : MonoBehaviour

    {

        // Token: 0x060000BD RID: 189 RVA: 0x00006B99 File Offset: 0x00004D99

        private void Awake()

        {

            this.m_TextComponent = base.GetComponent<TMP_Text>();

        }



        // Token: 0x060000BE RID: 190 RVA: 0x00006BA7 File Offset: 0x00004DA7

        private void OnEnable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000BF RID: 191 RVA: 0x00006BBF File Offset: 0x00004DBF

        private void OnDisable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000C0 RID: 192 RVA: 0x00006BD7 File Offset: 0x00004DD7

        private void Start()

        {

            base.StartCoroutine(this.AnimateVertexColors());

        }



        // Token: 0x060000C1 RID: 193 RVA: 0x00006BE6 File Offset: 0x00004DE6

        private void ON_TEXT_CHANGED(Object obj)

        {

            if (obj == this.m_TextComponent)

            {

                this.hasTextChanged = true;

            }

        }



        // Token: 0x060000C2 RID: 194 RVA: 0x00006BFD File Offset: 0x00004DFD

        private IEnumerator AnimateVertexColors()

        {

            this.m_TextComponent.ForceMeshUpdate(false, false);

            TMP_TextInfo textInfo = this.m_TextComponent.textInfo;

            int loopCount = 0;

            this.hasTextChanged = true;

            VertexJitter.VertexAnim[] vertexAnim = new VertexJitter.VertexAnim[1024];

            for (int i = 0; i < 1024; i++)

            {

                vertexAnim[i].angleRange = Random.Range(10f, 25f);

                vertexAnim[i].speed = Random.Range(1f, 3f);

            }

            TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();

            for (;;)

            {

                if (this.hasTextChanged)

                {

                    cachedMeshInfo = textInfo.CopyMeshInfoVertexData();

                    this.hasTextChanged = false;

                }

                int characterCount = textInfo.characterCount;

                if (characterCount == 0)

                {

                    yield return new WaitForSeconds(0.25f);

                }

                else

                {

                    for (int j = 0; j < characterCount; j++)

                    {

                        if (textInfo.characterInfo[j].isVisible)

                        {

                            VertexJitter.VertexAnim vertexAnim2 = vertexAnim[j];

                            int materialReferenceIndex = textInfo.characterInfo[j].materialReferenceIndex;

                            int vertexIndex = textInfo.characterInfo[j].vertexIndex;

                            Vector3[] vertices = cachedMeshInfo[materialReferenceIndex].vertices;

                            Vector3 vector = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;

                            Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;

                            vertices2[vertexIndex] = vertices[vertexIndex] - vector;

                            vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;

                            vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;

                            vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;

                            vertexAnim2.angle = Mathf.SmoothStep(-vertexAnim2.angleRange, vertexAnim2.angleRange, Mathf.PingPong((float)loopCount / 25f * vertexAnim2.speed, 1f));

                            Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(Random.Range(-0.25f, 0.25f), Random.Range(-0.25f, 0.25f), 0f) * this.CurveScale, Quaternion.Euler(0f, 0f, Random.Range(-5f, 5f) * this.AngleMultiplier), Vector3.one);

                            vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);

                            vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);

                            vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);

                            vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);

                            vertices2[vertexIndex] += vector;

                            vertices2[vertexIndex + 1] += vector;

                            vertices2[vertexIndex + 2] += vector;

                            vertices2[vertexIndex + 3] += vector;

                            vertexAnim[j] = vertexAnim2;

                        }

                    }

                    for (int k = 0; k < textInfo.meshInfo.Length; k++)

                    {

                        textInfo.meshInfo[k].mesh.vertices = textInfo.meshInfo[k].vertices;

                        this.m_TextComponent.UpdateGeometry(textInfo.meshInfo[k].mesh, k);

                    }

                    loopCount++;

                    yield return new WaitForSeconds(0.1f);

                }

            }

            yield break;

        }



        // Token: 0x040000F1 RID: 241

        public float AngleMultiplier = 1f;



        // Token: 0x040000F2 RID: 242

        public float SpeedMultiplier = 1f;



        // Token: 0x040000F3 RID: 243

        public float CurveScale = 1f;



        // Token: 0x040000F4 RID: 244

        private TMP_Text m_TextComponent;



        // Token: 0x040000F5 RID: 245

        private bool hasTextChanged;



        // Token: 0x02000052 RID: 82

        private struct VertexAnim

        {

            // Token: 0x04000178 RID: 376

            public float angleRange;



            // Token: 0x04000179 RID: 377

            public float angle;



            // Token: 0x0400017A RID: 378

            public float speed;

        }

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000034 RID: 52

    public class VertexShakeA : MonoBehaviour

    {

        // Token: 0x060000C4 RID: 196 RVA: 0x00006C35 File Offset: 0x00004E35

        private void Awake()

        {

            this.m_TextComponent = base.GetComponent<TMP_Text>();

        }



        // Token: 0x060000C5 RID: 197 RVA: 0x00006C43 File Offset: 0x00004E43

        private void OnEnable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000C6 RID: 198 RVA: 0x00006C5B File Offset: 0x00004E5B

        private void OnDisable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000C7 RID: 199 RVA: 0x00006C73 File Offset: 0x00004E73

        private void Start()

        {

            base.StartCoroutine(this.AnimateVertexColors());

        }



        // Token: 0x060000C8 RID: 200 RVA: 0x00006C82 File Offset: 0x00004E82

        private void ON_TEXT_CHANGED(Object obj)

        {

            if (this.m_TextComponent)

            {

                this.hasTextChanged = true;

            }

        }



        // Token: 0x060000C9 RID: 201 RVA: 0x00006C9B File Offset: 0x00004E9B

        private IEnumerator AnimateVertexColors()

        {

            this.m_TextComponent.ForceMeshUpdate(false, false);

            TMP_TextInfo textInfo = this.m_TextComponent.textInfo;

            Vector3[][] copyOfVertices = new Vector3[0][];

            this.hasTextChanged = true;

            for (;;)

            {

                if (this.hasTextChanged)

                {

                    if (copyOfVertices.Length < textInfo.meshInfo.Length)

                    {

                        copyOfVertices = new Vector3[textInfo.meshInfo.Length][];

                    }

                    for (int i = 0; i < textInfo.meshInfo.Length; i++)

                    {

                        int num = textInfo.meshInfo[i].vertices.Length;

                        copyOfVertices[i] = new Vector3[num];

                    }

                    this.hasTextChanged = false;

                }

                if (textInfo.characterCount == 0)

                {

                    yield return new WaitForSeconds(0.25f);

                }

                else

                {

                    int lineCount = textInfo.lineCount;

                    for (int j = 0; j < lineCount; j++)

                    {

                        int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;

                        int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;

                        Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;

                        Quaternion quaternion = Quaternion.Euler(0f, 0f, Random.Range(-0.25f, 0.25f) * this.RotationMultiplier);

                        for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)

                        {

                            if (textInfo.characterInfo[k].isVisible)

                            {

                                int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;

                                int vertexIndex = textInfo.characterInfo[k].vertexIndex;

                                Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;

                                copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector;

                                float num2 = Random.Range(0.995f - 0.001f * this.ScaleMultiplier, 1.005f + 0.001f * this.ScaleMultiplier);

                                Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, quaternion, Vector3.one * num2);

                                copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);

                                copyOfVertices[materialReferenceIndex][vertexIndex] += vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;

                            }

                        }

                    }

                    for (int l = 0; l < textInfo.meshInfo.Length; l++)

                    {

                        textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];

                        this.m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);

                    }

                    yield return new WaitForSeconds(0.1f);

                }

            }

            yield break;

        }



        // Token: 0x040000F6 RID: 246

        public float AngleMultiplier = 1f;



        // Token: 0x040000F7 RID: 247

        public float SpeedMultiplier = 1f;



        // Token: 0x040000F8 RID: 248

        public float ScaleMultiplier = 1f;



        // Token: 0x040000F9 RID: 249

        public float RotationMultiplier = 1f;



        // Token: 0x040000FA RID: 250

        private TMP_Text m_TextComponent;



        // Token: 0x040000FB RID: 251

        private bool hasTextChanged;

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000035 RID: 53

    public class VertexShakeB : MonoBehaviour

    {

        // Token: 0x060000CB RID: 203 RVA: 0x00006CDE File Offset: 0x00004EDE

        private void Awake()

        {

            this.m_TextComponent = base.GetComponent<TMP_Text>();

        }



        // Token: 0x060000CC RID: 204 RVA: 0x00006CEC File Offset: 0x00004EEC

        private void OnEnable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000CD RID: 205 RVA: 0x00006D04 File Offset: 0x00004F04

        private void OnDisable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000CE RID: 206 RVA: 0x00006D1C File Offset: 0x00004F1C

        private void Start()

        {

            base.StartCoroutine(this.AnimateVertexColors());

        }



        // Token: 0x060000CF RID: 207 RVA: 0x00006D2B File Offset: 0x00004F2B

        private void ON_TEXT_CHANGED(Object obj)

        {

            if (this.m_TextComponent)

            {

                this.hasTextChanged = true;

            }

        }



        // Token: 0x060000D0 RID: 208 RVA: 0x00006D44 File Offset: 0x00004F44

        private IEnumerator AnimateVertexColors()

        {

            this.m_TextComponent.ForceMeshUpdate(false, false);

            TMP_TextInfo textInfo = this.m_TextComponent.textInfo;

            Vector3[][] copyOfVertices = new Vector3[0][];

            this.hasTextChanged = true;

            for (;;)

            {

                if (this.hasTextChanged)

                {

                    if (copyOfVertices.Length < textInfo.meshInfo.Length)

                    {

                        copyOfVertices = new Vector3[textInfo.meshInfo.Length][];

                    }

                    for (int i = 0; i < textInfo.meshInfo.Length; i++)

                    {

                        int num = textInfo.meshInfo[i].vertices.Length;

                        copyOfVertices[i] = new Vector3[num];

                    }

                    this.hasTextChanged = false;

                }

                if (textInfo.characterCount == 0)

                {

                    yield return new WaitForSeconds(0.25f);

                }

                else

                {

                    int lineCount = textInfo.lineCount;

                    for (int j = 0; j < lineCount; j++)

                    {

                        int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;

                        int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;

                        Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;

                        Quaternion quaternion = Quaternion.Euler(0f, 0f, Random.Range(-0.25f, 0.25f));

                        for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)

                        {

                            if (textInfo.characterInfo[k].isVisible)

                            {

                                int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;

                                int vertexIndex = textInfo.characterInfo[k].vertexIndex;

                                Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;

                                Vector3 vector2 = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;

                                copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector2;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector2;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector2;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector2;

                                float num2 = Random.Range(0.95f, 1.05f);

                                Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * num2);

                                copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);

                                copyOfVertices[materialReferenceIndex][vertexIndex] += vector2;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector2;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector2;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector2;

                                copyOfVertices[materialReferenceIndex][vertexIndex] -= vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] -= vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] -= vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] -= vector;

                                matrix4x = Matrix4x4.TRS(Vector3.one, quaternion, Vector3.one);

                                copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);

                                copyOfVertices[materialReferenceIndex][vertexIndex] += vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;

                                copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;

                            }

                        }

                    }

                    for (int l = 0; l < textInfo.meshInfo.Length; l++)

                    {

                        textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];

                        this.m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);

                    }

                    yield return new WaitForSeconds(0.1f);

                }

            }

            yield break;

        }



        // Token: 0x040000FC RID: 252

        public float AngleMultiplier = 1f;



        // Token: 0x040000FD RID: 253

        public float SpeedMultiplier = 1f;



        // Token: 0x040000FE RID: 254

        public float CurveScale = 1f;



        // Token: 0x040000FF RID: 255

        private TMP_Text m_TextComponent;



        // Token: 0x04000100 RID: 256

        private bool hasTextChanged;

    }

}



using System;

using System.Collections;

using System.Collections.Generic;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000036 RID: 54

    public class VertexZoom : MonoBehaviour

    {

        // Token: 0x060000D2 RID: 210 RVA: 0x00006D7C File Offset: 0x00004F7C

        private void Awake()

        {

            this.m_TextComponent = base.GetComponent<TMP_Text>();

        }



        // Token: 0x060000D3 RID: 211 RVA: 0x00006D8A File Offset: 0x00004F8A

        private void OnEnable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000D4 RID: 212 RVA: 0x00006DA2 File Offset: 0x00004FA2

        private void OnDisable()

        {

            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(new Action<Object>(this.ON_TEXT_CHANGED));

        }



        // Token: 0x060000D5 RID: 213 RVA: 0x00006DBA File Offset: 0x00004FBA

        private void Start()

        {

            base.StartCoroutine(this.AnimateVertexColors());

        }



        // Token: 0x060000D6 RID: 214 RVA: 0x00006DC9 File Offset: 0x00004FC9

        private void ON_TEXT_CHANGED(Object obj)

        {

            if (obj == this.m_TextComponent)

            {

                this.hasTextChanged = true;

            }

        }



        // Token: 0x060000D7 RID: 215 RVA: 0x00006DE0 File Offset: 0x00004FE0

        private IEnumerator AnimateVertexColors()

        {

            this.m_TextComponent.ForceMeshUpdate(false, false);

            TMP_TextInfo textInfo = this.m_TextComponent.textInfo;

            TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();

            List<float> modifiedCharScale = new List<float>();

            List<int> scaleSortingOrder = new List<int>();

            this.hasTextChanged = true;

            Comparison<int> <>9__0;

            for (;;)

            {

                if (this.hasTextChanged)

                {

                    cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();

                    this.hasTextChanged = false;

                }

                int characterCount = textInfo.characterCount;

                if (characterCount == 0)

                {

                    yield return new WaitForSeconds(0.25f);

                }

                else

                {

                    modifiedCharScale.Clear();

                    scaleSortingOrder.Clear();

                    for (int i = 0; i < characterCount; i++)

                    {

                        if (textInfo.characterInfo[i].isVisible)

                        {

                            int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;

                            int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                            Vector3[] vertices = cachedMeshInfoVertexData[materialReferenceIndex].vertices;

                            Vector3 vector = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;

                            Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;

                            vertices2[vertexIndex] = vertices[vertexIndex] - vector;

                            vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;

                            vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;

                            vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;

                            float num = Random.Range(1f, 1.5f);

                            modifiedCharScale.Add(num);

                            scaleSortingOrder.Add(modifiedCharScale.Count - 1);

                            Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, Vector3.one * num);

                            vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);

                            vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);

                            vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);

                            vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);

                            vertices2[vertexIndex] += vector;

                            vertices2[vertexIndex + 1] += vector;

                            vertices2[vertexIndex + 2] += vector;

                            vertices2[vertexIndex + 3] += vector;

                            Vector4[] uvs = cachedMeshInfoVertexData[materialReferenceIndex].uvs0;

                            Vector4[] uvs2 = textInfo.meshInfo[materialReferenceIndex].uvs0;

                            uvs2[vertexIndex] = uvs[vertexIndex];

                            uvs2[vertexIndex + 1] = uvs[vertexIndex + 1];

                            uvs2[vertexIndex + 2] = uvs[vertexIndex + 2];

                            uvs2[vertexIndex + 3] = uvs[vertexIndex + 3];

                            Color32[] colors = cachedMeshInfoVertexData[materialReferenceIndex].colors32;

                            Color32[] colors2 = textInfo.meshInfo[materialReferenceIndex].colors32;

                            colors2[vertexIndex] = colors[vertexIndex];

                            colors2[vertexIndex + 1] = colors[vertexIndex + 1];

                            colors2[vertexIndex + 2] = colors[vertexIndex + 2];

                            colors2[vertexIndex + 3] = colors[vertexIndex + 3];

                        }

                    }

                    for (int j = 0; j < textInfo.meshInfo.Length; j++)

                    {

                        List<int> list = scaleSortingOrder;

                        Comparison<int> comparison;

                        if ((comparison = <>9__0) == null)

                        {

                            comparison = (<>9__0 = (int a, int b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b]));

                        }

                        list.Sort(comparison);

                        textInfo.meshInfo[j].SortGeometry(scaleSortingOrder);

                        textInfo.meshInfo[j].mesh.vertices = textInfo.meshInfo[j].vertices;

                        textInfo.meshInfo[j].mesh.SetUVs(0, textInfo.meshInfo[j].uvs0);

                        textInfo.meshInfo[j].mesh.colors32 = textInfo.meshInfo[j].colors32;

                        this.m_TextComponent.UpdateGeometry(textInfo.meshInfo[j].mesh, j);

                    }

                    yield return new WaitForSeconds(0.1f);

                }

            }

            yield break;

        }



        // Token: 0x04000101 RID: 257

        public float AngleMultiplier = 1f;



        // Token: 0x04000102 RID: 258

        public float SpeedMultiplier = 1f;



        // Token: 0x04000103 RID: 259

        public float CurveScale = 1f;



        // Token: 0x04000104 RID: 260

        private TMP_Text m_TextComponent;



        // Token: 0x04000105 RID: 261

        private bool hasTextChanged;

    }

}



using System;

using System.Collections;

using UnityEngine;



namespace TMPro.Examples

{

    // Token: 0x02000037 RID: 55

    public class WarpTextExample : MonoBehaviour

    {

        // Token: 0x060000D9 RID: 217 RVA: 0x00006E18 File Offset: 0x00005018

        private void Awake()

        {

            this.m_TextComponent = base.gameObject.GetComponent<TMP_Text>();

        }



        // Token: 0x060000DA RID: 218 RVA: 0x00006E2B File Offset: 0x0000502B

        private void Start()

        {

            base.StartCoroutine(this.WarpText());

        }



        // Token: 0x060000DB RID: 219 RVA: 0x00006E3A File Offset: 0x0000503A

        private AnimationCurve CopyAnimationCurve(AnimationCurve curve)

        {

            return new AnimationCurve

            {

                keys = curve.keys

            };

        }



        // Token: 0x060000DC RID: 220 RVA: 0x00006E4D File Offset: 0x0000504D

        private IEnumerator WarpText()

        {

            this.VertexCurve.preWrapMode = WrapMode.Once;

            this.VertexCurve.postWrapMode = WrapMode.Once;

            this.m_TextComponent.havePropertiesChanged = true;

            this.CurveScale *= 10f;

            float old_CurveScale = this.CurveScale;

            AnimationCurve old_curve = this.CopyAnimationCurve(this.VertexCurve);

            for (;;)

            {

                if (!this.m_TextComponent.havePropertiesChanged && old_CurveScale == this.CurveScale && old_curve.keys[1].value == this.VertexCurve.keys[1].value)

                {

                    yield return null;

                }

                else

                {

                    old_CurveScale = this.CurveScale;

                    old_curve = this.CopyAnimationCurve(this.VertexCurve);

                    this.m_TextComponent.ForceMeshUpdate(false, false);

                    TMP_TextInfo textInfo = this.m_TextComponent.textInfo;

                    int characterCount = textInfo.characterCount;

                    if (characterCount != 0)

                    {

                        float x = this.m_TextComponent.bounds.min.x;

                        float x2 = this.m_TextComponent.bounds.max.x;

                        for (int i = 0; i < characterCount; i++)

                        {

                            if (textInfo.characterInfo[i].isVisible)

                            {

                                int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                                int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;

                                Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;

                                Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);

                                vertices[vertexIndex] += -vector;

                                vertices[vertexIndex + 1] += -vector;

                                vertices[vertexIndex + 2] += -vector;

                                vertices[vertexIndex + 3] += -vector;

                                float num = (vector.x - x) / (x2 - x);

                                float num2 = num + 0.0001f;

                                float num3 = this.VertexCurve.Evaluate(num) * this.CurveScale;

                                float num4 = this.VertexCurve.Evaluate(num2) * this.CurveScale;

                                Vector3 vector2 = new Vector3(1f, 0f, 0f);

                                Vector3 vector3 = new Vector3(num2 * (x2 - x) + x, num4) - new Vector3(vector.x, num3);

                                float num5 = Mathf.Acos(Vector3.Dot(vector2, vector3.normalized)) * 57.29578f;

                                float num6 = ((Vector3.Cross(vector2, vector3).z > 0f) ? num5 : (360f - num5));

                                Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, num3, 0f), Quaternion.Euler(0f, 0f, num6), Vector3.one);

                                vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);

                                vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);

                                vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);

                                vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                                vertices[vertexIndex] += vector;

                                vertices[vertexIndex + 1] += vector;

                                vertices[vertexIndex + 2] += vector;

                                vertices[vertexIndex + 3] += vector;

                            }

                        }

                        this.m_TextComponent.UpdateVertexData();

                        yield return new WaitForSeconds(0.025f);

                    }

                }

            }

            yield break;

        }



        // Token: 0x04000106 RID: 262

        private TMP_Text m_TextComponent;



        // Token: 0x04000107 RID: 263

        public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe[]

        {

            new Keyframe(0f, 0f),

            new Keyframe(0.25f, 2f),

            new Keyframe(0.5f, 0f),

            new Keyframe(0.75f, 2f),

            new Keyframe(1f, 0f)

        });



        // Token: 0x04000108 RID: 264

        public float AngleMultiplier = 1f;



        // Token: 0x04000109 RID: 265

        public float SpeedMultiplier = 1f;



        // Token: 0x0400010A RID: 266

        public float CurveScale = 1f;

    }

}



using System;

using UnityEngine;



namespace TMPro

{

    // Token: 0x0200001A RID: 26

    [Serializable]

    public class TMP_PhoneNumberValidator : TMP_InputValidator

    {

        // Token: 0x06000047 RID: 71 RVA: 0x00002F6C File Offset: 0x0000116C

        public override char Validate(ref string text, ref int pos, char ch)

        {

            Debug.Log("Trying to validate...");

            if (ch < '0' && ch > '9')

            {

                return '\0';

            }

            int length = text.Length;

            for (int i = 0; i < length + 1; i++)

            {

                switch (i)

                {

                case 0:

                    if (i == length)

                    {

                        text = "(" + ch.ToString();

                    }

                    pos = 2;

                    break;

                case 1:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 2;

                    break;

                case 2:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 3;

                    break;

                case 3:

                    if (i == length)

                    {

                        text = text + ch.ToString() + ") ";

                    }

                    pos = 6;

                    break;

                case 4:

                    if (i == length)

                    {

                        text = text + ") " + ch.ToString();

                    }

                    pos = 7;

                    break;

                case 5:

                    if (i == length)

                    {

                        text = text + " " + ch.ToString();

                    }

                    pos = 7;

                    break;

                case 6:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 7;

                    break;

                case 7:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 8;

                    break;

                case 8:

                    if (i == length)

                    {

                        text = text + ch.ToString() + "-";

                    }

                    pos = 10;

                    break;

                case 9:

                    if (i == length)

                    {

                        text = text + "-" + ch.ToString();

                    }

                    pos = 11;

                    break;

                case 10:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 11;

                    break;

                case 11:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 12;

                    break;

                case 12:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 13;

                    break;

                case 13:

                    if (i == length)

                    {

                        text += ch.ToString();

                    }

                    pos = 14;

                    break;

                }

            }

            return ch;

        }

    }

}