P = [46370304604399661103510587278608860854, 161470033739550046992102957507284694793, 30543660898063616156789781040944567751, 250664599838920908776562323596516643000, 139374138362514071242477757778171360453, 123592723058786214120596739563194410238, 211661190966175954206312604476025891883, 204127984470558401029942508675826118636, 226485320614749484977835154691419711643, 316359778276308230428825295117172452569, 223595536749391578996034934226276385201, 285194897737688239593933128294126253420, 106767966397120299297689471215328740769, 25599906753022130965000372964020080374, 99461971332517921483061891799425259113, 94027794705920646966871149109862801610, 123296061030051008330943248360079826013, 74854535529342502478954289154224576092, 224885683431821751400008043275824815646, 266096166425088007499970985584050784682, 276003343849704749424463898987980442737, 102681588182470124247526654172102644907, 81066074715052040596846980190467140543, 288564406824785492891304803256068657153, 275777490926285666099408286534129620445, 282517686156702650031304218971561203305, 303283907912734438658673255308488382253, 207124905215590627556917580593810100294, 280558080079068849809690254471376167991, 160954151682440634237745640217189791793, 97767119790212416603441928990664031378, 338144640821518318947395128924719917222, 175619923321070422554784972534849507595, 254564156262627389965162628894875365269, 196177539698888734927195275991945056566, 316218059699388548025737940688917830572, 268400154682066693679616423870021647142, 215171060317966594124409556912523500752, 260057877459608494186977306109025707665, 190102548117865681721849886759598482779, 252725419899497668403547022908880618059, 327335827827878566866970242836185642452, 188260325012018828319115719433455849371, 88483421141682536040965596554472029136, 310248075203863607523992695030757874632, 295640402932812162029270725799625344492, 70276872614365224915426973058582085536, 256094493760578638941104549543294911438, 42841363734929118457515014374580961350, 128080761902152925446804036416229034376, 180236556373329949311891716497015905345, 109842713274004118912686485592449650056, 193653151004110836304303931934828586594, 217480566371177947463788535587066608900, 85737645843034151047932615174569760367, 75130577098367771493769881166880018519, 44108879264846109022147939103515256917, 200510426260508215019844361235980313468, 57239393388118598756306963809052694810, 285120374875743578681171629134755246113, 310860836570193120117077183155691495035, 251862421155813445159906426270135772925, 301796605933628926886822581638474528587, 338556933792869391731776683003533084480]
C = [6431903975558659411995736450941742463678, 6798319334988101743518674132084696585109, 6515613864583459558948036293342639545155, 7773122108332461536899295384273685725884, 7116134977799359563372944976071555756181, 6933621053828258679307411351393495758849]
# solve_extended.py
from math import gcd
from itertools import permutations
import sys

def invmod(x, m):
    try:
        return pow(x, -1, m)
    except ValueError:
        return None

def is_superincreasing(seq):
    total = 0
    for v in seq:
        if v <= total:
            return False
        total += v
    return True

def greedy_solve_superincreasing(w, S):
    bits = [0]*len(w)
    total = S
    for i in range(len(w)-1, -1, -1):
        if w[i] <= total:
            bits[i] = 1
            total -= w[i]
    if total != 0:
        return None
    return bits

def bits_to_bytes_be(bits):
    out = bytearray()
    for i in range(0, len(bits), 8):
        b = 0
        for k in range(8):
            b = (b << 1) | bits[i+k]
        out.append(b)
    return bytes(out)

def try_attack(P, C, w0_min=1025, w0_max=4096, t_min=0, t_max=255, verbose=True):
    pow2_128 = 1 << 128
    for t in range(t_min, t_max+1):
        M = pow2_128 + t
        A0 = P[0]
        invA0 = invmod(A0, M)
        if invA0 is None:
            if verbose: print(f"t={t}: A0 not invertible mod M")
            continue
        if verbose: print(f"Trying t={t} (M=2^128+{t}) ...")
        for w0 in range(w0_min, w0_max+1):
            a_inv = (w0 * invA0) % M
            w_candidate = [ (a_inv * ai) % M for ai in P ]
            if is_superincreasing(w_candidate):
                print("[+] Found candidate M =", M, " (t=", t, "), w0 =", w0)
                return M, a_inv, w_candidate
    return None, None, None

if __name__ == "__main__":
    if not P or not C:
        print("ERROR: Chưa dán P và C đầy đủ vào file.")
        sys.exit(1)

    # thử dải mặc định (giống prob.py)
    print("Step1: thử dải tiêu chuẩn t=0..255, w0=1025..4096")
    M,a_inv,w = try_attack(P,C,1025,4096,0,255,True)
    if M:
        print("Found. Will attempt decrypting.")
    else:
        print("Không tìm thấy trong dải tiêu chuẩn. Bắt đầu mở rộng...")
        # mở rộng w0 dải lớn hơn
        M,a_inv,w = try_attack(P,C,256,1<<16,0,255,False)
        if M:
            print("Found in extended w0 range.")
        else:
            # thử t rộng hơn (thường không cần) - in log và dừng
            print("Không tìm thấy sau mở rộng. Bạn có thể thử chạy thêm: tăng max w0, hoặc kiểm tra xem P có bị 'permuted' hay không.")
            sys.exit(2)

    # nếu tìm thấy thì giải các khối C thành plaintext
    plaintext = b""
    for S in C:
        Sprime = (a_inv * S) % M
        bits = greedy_solve_superincreasing(w, Sprime)
        if bits is None:
            print("Failed to decompose S' =", Sprime)
            sys.exit(3)
        b = bits_to_bytes_be(bits)
        plaintext += b
    print("[+] Plaintext (raw):", plaintext)
    try:
        print("[+] Plaintext (utf-8):", plaintext.decode())
    except:
        print("[+] Plaintext không phải utf-8; in raw bytes.")
