#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
unixor solver
-------------
Recover fwectf{...} from XOR of a Japanese UTF-8 novel with a repeating key.
Given: encrypted.txt (bytes), generated by: c[i] = p[i] ^ key[i % len(key)]
Assumptions:
- key (the FLAG) is ASCII: "fwectf{[a-z0-9_]+}"
- 9 <= len(key) < 30
- plaintext is valid UTF-8 (no BOM), uses LF newlines
Strategy:
- Try each possible key length L and build the key byte-by-byte with backtracking.
- We constrain characters to the allowed flag charset and known prefix/suffix.
- At each step, we check whether the partially decrypted stream can still be extended
  to a valid UTF-8 string using a small UTF-8 DFA that supports partial knowledge.
- When the key is fully built, we decrypt and verify the entire plaintext is valid UTF-8.
Prints the recovered flag(s) and optionally saves the recovered novel.
"""

from typing import List, Optional, Tuple, Dict
import sys
import os

ALLOWED_INSIDE = b"abcdefghijklmnopqrstuvwxyz0123456789_"
PREFIX = b"fwectf{"
SUFFIX = b"}"

def read_cipher(path: str) -> bytes:
    with open(path, "rb") as f:
        return f.read()

# UTF-8 validation that can handle partially-known bytes.
# We store the set of positions that are "known" (i.e., we know p[i] because key byte is known)
# and check for contradictions in what we know so far.
def utf8_partial_ok(p: List[Optional[int]]) -> bool:
    i = 0
    n = len(p)
    while i < n:
        b = p[i]
        if b is None:
            # Unknown byte; we can't assert anything, but we must ensure
            # that future known bytes don't contradict. To keep pruning effective,
            # we try to avoid starting a multi-byte span if continuation byte is known bad.
            i += 1
            continue
        # ASCII
        if b <= 0x7F:
            i += 1
            continue
        # 2-byte start: 110xxxxx
        if 0xC2 <= b <= 0xDF:
            if i + 1 >= n:
                return True  # incomplete at end is fine for partial check
            b1 = p[i + 1]
            if b1 is not None and not (0x80 <= b1 <= 0xBF):
                return False
            i += 2
            continue
        # 3-byte start:
        if b == 0xE0:
            # next must be 0xA0..0xBF, then 0x80..0xBF
            if i + 1 < n:
                b1 = p[i + 1]
                if b1 is not None and not (0xA0 <= b1 <= 0xBF):
                    return False
            if i + 2 < n:
                b2 = p[i + 2]
                if b2 is not None and not (0x80 <= b2 <= 0xBF):
                    return False
            i += 3
            continue
        if 0xE1 <= b <= 0xEC or b == 0xEE or b == 0xEF:
            # next two: 0x80..0xBF
            if i + 1 < n:
                b1 = p[i + 1]
                if b1 is not None and not (0x80 <= b1 <= 0xBF):
                    return False
            if i + 2 < n:
                b2 = p[i + 2]
                if b2 is not None and not (0x80 <= b2 <= 0xBF):
                    return False
            i += 3
            continue
        if b == 0xED:
            # next must be 0x80..0x9F, then 0x80..0xBF (avoid surrogates)
            if i + 1 < n:
                b1 = p[i + 1]
                if b1 is not None and not (0x80 <= b1 <= 0x9F):
                    return False
            if i + 2 < n:
                b2 = p[i + 2]
                if b2 is not None and not (0x80 <= b2 <= 0xBF):
                    return False
            i += 3
            continue
        # 4-byte start:
        if b == 0xF0:
            # 0x90..0xBF, then 0x80..0xBF, then 0x80..0xBF
            if i + 1 < n:
                b1 = p[i + 1]
                if b1 is not None and not (0x90 <= b1 <= 0xBF):
                    return False
            if i + 2 < n:
                b2 = p[i + 2]
                if b2 is not None and not (0x80 <= b2 <= 0xBF):
                    return False
            if i + 3 < n:
                b3 = p[i + 3]
                if b3 is not None and not (0x80 <= b3 <= 0xBF):
                    return False
            i += 4
            continue
        if 0xF1 <= b <= 0xF3:
            for off in (1, 2, 3):
                if i + off < n:
                    bb = p[i + off]
                    if bb is not None and not (0x80 <= bb <= 0xBF):
                        return False
            i += 4
            continue
        if b == 0xF4:
            # 0x80..0x8F, then 0x80..0xBF, then 0x80..0xBF
            if i + 1 < n:
                b1 = p[i + 1]
                if b1 is not None and not (0x80 <= b1 <= 0x8F):
                    return False
            if i + 2 < n:
                b2 = p[i + 2]
                if b2 is not None and not (0x80 <= b2 <= 0xBF):
                    return False
            if i + 3 < n:
                b3 = p[i + 3]
                if b3 is not None and not (0x80 <= b3 <= 0xBF):
                    return False
            i += 4
            continue
        # Continuation byte (0x80..0xBF) without a known start is ambiguous in partial view;
        # reject only if we can prove it's impossible (i.e., previous known byte can't start a sequence).
        if 0x80 <= b <= 0xBF:
            # If previous byte is known ASCII or None, we can't be sure; allow for now.
            i += 1
            continue
        # 0xC0,0xC1 and >0xF4 are invalid starts
        return False
    return True

def try_length(c: bytes, L: int) -> List[bytes]:
    # Key template as Optional[int]; we'll fill bytes as we go.
    key = [None] * L  # type: List[Optional[int]]
    # Apply known prefix and suffix shape
    if L < len(PREFIX) + 1 + 1:  # fwectf{ } minimal inside is 1 char
        return []
    # Positions for prefix "fwectf{"
    for i, ch in enumerate(PREFIX):
        key[i] = ch
    # Positions for suffix "}" at the end of key
    key[-1] = SUFFIX[0]
    # Inside braces indices range
    inside_idx = list(range(len(PREFIX), L - 1))

    # Allowed bytes for inside
    allowed = list(ALLOWED_INSIDE)

    # Precompute cipher columns by position mod L
    cols = [c[i::L] for i in range(L)]
    n = len(c)

    # helper to build partial plaintext bytes list given partial key
    def partial_plain(key_local: List[Optional[int]]) -> List[Optional[int]]:
        p = [None] * n
        for i in range(n):
            kb = key_local[i % L]
            if kb is not None:
                p[i] = c[i] ^ kb
        return p

    solutions = []
    visited: Dict[Tuple[Optional[int], ...], bool] = {}

    # Seed immediate contradictions for prefix/suffix against UTF-8
    if not utf8_partial_ok(partial_plain(key)):
        return []

    # DFS over inside positions in order; choose an order that touches more bytes first to prune early.
    # Each key byte affects roughly ceil(n/L) plaintext bytes; all equal, so keep natural order.
    def dfs(pos: int):
        if pos == len(inside_idx):
            # Full key filled; verify full plaintext is valid UTF-8
            kbytes = bytes([(kb if kb is not None else 0) for kb in key])
            # If some key slots still None (shouldn't), abort
            if any(kb is None for kb in key):
                return
            p = bytes([c[i] ^ kbytes[i % L] for i in range(n)])
            try:
                text = p.decode('utf-8')
            except UnicodeDecodeError:
                return
            # Additional sanity checks: likely Japanese and LF newlines
            if text.count('\n') == 0:
                return
            # All good
            solutions.append(kbytes)
            return

        kpos = inside_idx[pos]
        state_tuple = tuple(key)
        if state_tuple in visited:
            return
        visited[state_tuple] = True

        for ch in allowed:
            key[kpos] = ch
            # Early pruning: enforce utf-8 partial validity
            if utf8_partial_ok(partial_plain(key)):
                dfs(pos + 1)
            key[kpos] = None  # backtrack

    dfs(0)
    return solutions

def main():
    path = "encrypted.txt"
    if len(sys.argv) >= 2:
        path = sys.argv[1]
    if not os.path.exists(path):
        print(f"[-] Missing {path}. Put encrypted.txt next to this script or pass a path.", file=sys.stderr)
        sys.exit(1)
    c = read_cipher(path)
    print(f"[+] Loaded ciphertext: {len(c)} bytes")
    found = []
    for L in range(9, 30):  # min "fwectf{a}" len=9, max <30
        print(f"[*] Trying key length = {L} ...")
        sols = try_length(c, L)
        for k in sols:
            if not (k.startswith(PREFIX) and k.endswith(SUFFIX)):
                continue
            flag = k.decode('ascii', errors='ignore')
            print(f"[+] Candidate FLAG: {flag}")
            # confirm unique by decoding plaintext
            p = bytes(ci ^ k[i % len(k)] for i, ci in enumerate(c))
            try:
                novel = p.decode('utf-8')
            except UnicodeDecodeError:
                continue
            # Save novel for curiosity
            out = f"recovered_novel_len{L}.txt"
            with open(out, "w", encoding="utf-8", newline="\n") as f:
                f.write(novel)
            print(f"[+] Saved recovered novel to {out}")
            found.append(flag)
    if not found:
        print("[-] No valid flag found. If you know the allowed charset is different, tweak ALLOWED_INSIDE.")
    else:
        unique = sorted(set(found))
        print("[*] Flags found:")
        for f in unique:
            print(f"    {f}")
        if len(unique) == 1:
            print(f"[SUCCESS] FLAG = {unique[0]}")

if __name__ == "__main__":
    main()
