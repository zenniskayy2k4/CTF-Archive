

# This file was *autogenerated* from the file run.sage
from sage.all_cmdline import *   # import sage library

_sage_const_5000 = Integer(5000); _sage_const_10 = Integer(10); _sage_const_4096 = Integer(4096); _sage_const_40 = Integer(40); _sage_const_1000 = Integer(1000); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_21 = Integer(21); _sage_const_0 = Integer(0); _sage_const_42 = Integer(42); _sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_20 = Integer(20)
import socket
import sys
from bisect import bisect_left
from Crypto.Util.number import long_to_bytes, bytes_to_long

# --- Cấu hình ---
HOST = 'ctf.csd.lol'
PORT = _sage_const_5000 
PAYLOAD = b'flag'  # Chỉ dùng 'flag' để tối đa hóa khả năng tìm thấy

def solve():
    print(f"[+] Đang kết nối tới {HOST}:{PORT}...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((HOST, PORT))
        s.settimeout(_sage_const_10 )
        
        # Nhận dữ liệu
        buffer = b""
        while b"Your integer?" not in buffer:
            chunk = s.recv(_sage_const_4096 )
            if not chunk: break
            buffer += chunk
        
        data = buffer.decode('utf-8', errors='ignore')
        
        # Phân tích số nguyên tố
        primes = []
        for line in data.split('\n'):
            parts = line.strip().split()
            if len(parts) >= _sage_const_40 :
                try:
                    candidates = [int(x) for x in parts]
                    if all(x > _sage_const_1000  for x in candidates):
                        primes = candidates
                        break
                except: continue
        
        if not primes:
            print("[-] Không tìm thấy số nguyên tố.")
            return

        print(f"[+] Đã nhận {len(primes)} số nguyên tố.")
        
        # --- CHUẨN BỊ TOÁN HỌC ---
        ps = primes
        N = prod(ps)
        goods = [_sage_const_6 , _sage_const_7 ] # Tập trung vào gợi ý "6 7"
        
        # Tính trọng số CRT
        weights = []
        for p in ps:
            M = N // p
            y = inverse_mod(M, p)
            weights.append((M * y) % N)

        # --- GIAI ĐOẠN 1: MEET-IN-THE-MIDDLE ---
        mid = _sage_const_21 
        print("[*] Đang tạo bảng tra cứu (Meet-in-the-Middle)...")
        
        # Nửa Trái
        L = [_sage_const_0 ]
        for i in range(mid):
            w = weights[i]
            L = [(x + g * w) % N for x in L for g in goods]
        L.sort()
        
        # Nửa Phải
        R = [_sage_const_0 ]
        for i in range(mid, _sage_const_42 ):
            w = weights[i]
            R = [(x + g * w) % N for x in R for g in goods]

        # --- GIAI ĐOẠN 2: TÍNH TOÁN RANGE CHÍNH XÁC ---
        # Xác định độ dài byte của N
        n_len = (N.bit_length() + _sage_const_7 ) // _sage_const_8 
        
        # Thử 2 trường hợp: Payload ở độ dài n_len và n_len - 1
        possible_lengths = [n_len]
        if N.bit_length() % _sage_const_8  != _sage_const_0 : # Nếu N không tròn byte, có thể payload ngắn hơn
             possible_lengths.append(n_len - _sage_const_1 )

        solution_n = None

        print(f"[*] Bắt đầu quét {len(R)} phần tử nửa phải...")
        
        for r_val in R:
            for length in possible_lengths:
                # Tính toán khoảng Target cho độ dài này
                # Target: PAYLOAD + [00...00] đến PAYLOAD + [FF...FF]
                pad_len = length - len(PAYLOAD)
                if pad_len < _sage_const_0 : continue
                
                t_min = bytes_to_long(PAYLOAD + b'\x00' * pad_len)
                t_max = bytes_to_long(PAYLOAD + b'\xff' * pad_len)
                
                # Nếu khoảng target lớn hơn N, cắt bớt
                if t_min >= N: continue 
                t_max = min(t_max, N - _sage_const_1 )
                
                # Tìm l sao cho (l + r) % N thuộc [t_min, t_max]
                # => l thuộc [(t_min - r) % N, (t_max - r) % N]
                low = (t_min - r_val) % N
                high = (t_max - r_val) % N
                
                found_l = []
                if low <= high:
                    # Khoảng liên tục
                    idx = bisect_left(L, low)
                    while idx < len(L) and L[idx] <= high:
                        found_l.append(L[idx])
                        idx += _sage_const_1 
                else:
                    # Khoảng bị ngắt quãng qua N (Wrap-around)
                    # 1. [low, N-1]
                    idx = bisect_left(L, low)
                    while idx < len(L):
                        found_l.append(L[idx])
                        idx += _sage_const_1 
                    # 2. [0, high]
                    idx = _sage_const_0 
                    while idx < len(L) and L[idx] <= high:
                        found_l.append(L[idx])
                        idx += _sage_const_1 
                
                for l_val in found_l:
                    n = (l_val + r_val) % N
                    b = long_to_bytes(n)
                    # Kiểm tra chính xác
                    if b.startswith(PAYLOAD) and b'\n' not in b and b'\r' not in b:
                        solution_n = n
                        print(f"\n[!!!] TÌM THẤY SỐ N: {n}")
                        print(f"Bytes: {b[:_sage_const_20 ]}...")
                        break
                if solution_n: break
            if solution_n: break
        
        # --- GỬI KẾT QUẢ ---
        if solution_n:
            print("[*] Đang gửi kết quả tới server...")
            s.sendall(f"{solution_n}\n".encode('utf-8'))
            response = s.recv(_sage_const_4096 ).decode('utf-8')
            print("\n" + "="*_sage_const_40 )
            print("FLAG SERVER TRẢ VỀ:")
            print(response.strip())
            print("="*_sage_const_40 )
        else:
            print("[-] Vẫn không tìm thấy. Có thể payload cần 'flag#' thay vì 'flag' hoặc tập goods phức tạp hơn.")

    except Exception as e:
        print(f"Lỗi: {e}")
    finally:
        s.close()

if __name__ == "__main__":
    solve()

