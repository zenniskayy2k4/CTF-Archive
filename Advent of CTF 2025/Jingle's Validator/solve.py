import struct
from z3 import *

secret_bytes = b'\x3c\x6f\x53\x88\xd5\xf6\x00\x28\xb5\xbc\xab\x8b\x4d\xa6\xe2\x9a\x5b\x57\x10\xa4\x59\xd9\x56\x36\x01\x04\x51\xb0\xe1\xe2\x04\x0c\xe2\x35\xf8\x88\x6a\x2c\xcf\x29\xea\x2e\x73\x7e\x2a\xcc\xe9\x5f\x54\x35\x67\xd2'
bytecode = b'\x0f\x00\x00\x00\x04\x00\x13\x00\x00\x00\x05\x00\x01\x02\x00\x00\x00\x00\x04\x02\x00\x00\x04\x00\x12\x00\x00\x00\x06\x00\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x00\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x00\x00\x07\x03\x05\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x01\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x08\x00\x07\x03\x05\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x02\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x10\x00\x07\x03\x05\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x03\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x18\x00\x07\x03\x05\x00\x00\x00\x01\x04\x03\x00\x00\x00\x09\x04\x04\x00\x03\x00\x01\x05\x03\x00\x00\x00\x09\x05\x05\x00\x05\x00\x06\x04\x05\x00\x00\x00\x01\x05\x03\x00\x00\x00\x09\x05\x05\x00\x08\x00\x06\x04\x05\x00\x00\x00\x01\x05\x03\x00\x00\x00\x09\x05\x05\x00\x0c\x00\x06\x04\x05\x00\x00\x00\x0a\x04\x00\x00\xff\x00\x01\x05\x09\x00\x00\x00\x08\x05\x05\x00\x08\x00\x01\x09\x05\x00\x00\x00\x07\x09\x04\x00\x00\x00\x01\x0a\x09\x00\x00\x00\x01\x05\x00\x00\x00\x00\x05\x05\x01\x00\x00\x00\x10\x05\x00\x00\x00\x00\x13\x00\x00\x00\x8d\x00\x0f\x05\x00\x00\x04\x00\x13\x00\x00\x00\x34\x00\x00\x08\x00\x00\x04\x00\x12\x00\x00\x00\x35\x00\x01\x08\x05\x00\x00\x00\x01\x04\x09\x00\x00\x00\x09\x04\x04\x00\x03\x00\x01\x05\x09\x00\x00\x00\x09\x05\x05\x00\x05\x00\x06\x04\x05\x00\x00\x00\x01\x05\x09\x00\x00\x00\x09\x05\x05\x00\x08\x00\x06\x04\x05\x00\x00\x00\x01\x05\x09\x00\x00\x00\x09\x05\x05\x00\x0c\x00\x06\x04\x05\x00\x00\x00\x0a\x04\x00\x00\xff\x00\x01\x05\x09\x00\x00\x00\x08\x05\x05\x00\x08\x00\x01\x09\x05\x00\x00\x00\x07\x09\x04\x00\x00\x00\x01\x0a\x09\x00\x00\x00\x00\x0b\x00\x00\x00\x00\x0f\x08\x00\x00\x01\x00\x13\x00\x00\x00\x54\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x00\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x00\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x00\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x00\x00\x07\x0b\x06\x00\x00\x00\x0f\x08\x00\x00\x02\x00\x13\x00\x00\x00\x61\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x01\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x08\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x01\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x08\x00\x07\x0b\x06\x00\x00\x00\x0f\x08\x00\x00\x03\x00\x13\x00\x00\x00\x6e\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x02\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x10\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x02\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x10\x00\x07\x0b\x06\x00\x00\x00\x0f\x08\x00\x00\x04\x00\x13\x00\x00\x00\x7b\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x03\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x18\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x03\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x18\x00\x07\x0b\x06\x00\x00\x00\x01\x04\x0b\x00\x00\x00\x09\x04\x04\x00\x03\x00\x01\x05\x0b\x00\x00\x00\x09\x05\x05\x00\x05\x00\x06\x04\x05\x00\x00\x00\x01\x05\x0b\x00\x00\x00\x09\x05\x05\x00\x08\x00\x06\x04\x05\x00\x00\x00\x01\x05\x0b\x00\x00\x00\x09\x05\x05\x00\x0c\x00\x06\x04\x05\x00\x00\x00\x0a\x04\x00\x00\xff\x00\x01\x05\x09\x00\x00\x00\x08\x05\x05\x00\x08\x00\x01\x09\x05\x00\x00\x00\x07\x09\x04\x00\x00\x00\x02\x01\x00\x00\x04\x00\x12\x00\x00\x00\x2c\x00\x00\x0c\x00\x00\x00\x00\x01\x04\x00\x00\x00\x00\x05\x04\x0c\x00\x00\x00\x10\x04\x00\x00\x00\x00\x13\x00\x00\x00\x9a\x00\x0d\x05\x0c\x00\x00\x00\x0e\x06\x0c\x00\x00\x00\x11\x05\x06\x00\x00\x00\x14\x00\x00\x00\x98\x00\x02\x0c\x00\x00\x01\x00\x12\x00\x00\x00\x8e\x00\x15\x00\x00\x00\x00\x00\x16\x00\x00\x00\x00\x00\x15\x00\x00\x00\x01\x00\x16\x00\x00\x00\x00\x00'

# --- Z3 SOLVER ---
solver = Solver()
flag = [BitVec(f'f{i}', 8) for i in range(52)]
for c in flag:
    solver.add(c >= 32, c <= 126)

regs = {i: BitVecVal(0, 32) for i in range(100)}
vm_stack = {}
bVar13 = False

# === INIT REGISTERS ===
regs[0]  = BitVecVal(52, 32)
regs[9]  = BitVecVal(0xF337, 32)
regs[20] = BitVecVal(52, 32)
regs[22] = BitVecVal(52, 32)
regs[88] = BitVecVal(0xF337, 32)
# ==========================================

def get_imm(offset):
    try:
        val = bytecode[offset+4] | (bytecode[offset+5] << 8)
        if val & 0x8000: val -= 0x10000
        return val
    except: return 0

# START AT PC = 0 (Chạy từ đầu với dữ liệu đúng)
pc_index = 0
steps = 0
constraints_added = 0

print("[*] Starting VM with correct bytecode...")

while pc_index * 6 < len(bytecode) and steps < 100000:
    steps += 1
    offset = pc_index * 6
    
    try:
        op = bytecode[offset]
        dst = bytecode[offset+1]
        src = bytecode[offset+2]
    except IndexError: break
        
    imm = get_imm(offset)
    next_pc = pc_index + 1

    # --- OPCODE LOGIC ---
    if op == 0: regs[dst] = BitVecVal(imm, 32)
    elif op == 1: regs[dst] = regs[src]
    elif op == 2: regs[dst] += imm
    elif op == 3: regs[dst] += regs[src]
    elif op == 4: regs[dst] -= imm
    elif op == 5: regs[dst] -= regs[src]
    elif op == 6: regs[dst] ^= regs[src]
    elif op == 7: regs[dst] |= regs[src]
    elif op == 8: regs[dst] = regs[src] << (imm & 0x1F)
    elif op == 9: regs[dst] = LShR(regs[src], (imm & 0x1F))
    elif op == 10: regs[dst] &= imm
    
    elif op == 11: # LOAD INPUT
        idx = simplify(regs[src] + imm).as_long()
        if 0 <= idx < 52:
            regs[dst] = ZeroExt(24, flag[idx])
        else:
            regs[dst] = BitVecVal(0, 32)
            
    elif op == 12: vm_stack[simplify(regs[src] + imm).as_long()] = regs[dst]
    elif op == 13: regs[dst] = vm_stack.get(simplify(regs[src] + imm).as_long(), BitVecVal(0, 32))
    
    elif op == 14: # LOAD SECRET
        idx = simplify(regs[src] + imm).as_long()
        if 0 <= idx < 52:
            regs[dst] = BitVecVal(secret_bytes[idx], 32)
        else:
            regs[dst] = BitVecVal(0, 32)
            
    elif op == 15: # CMP <
        # Z3 cần biết rõ ràng True/False để nhảy
        concrete_val = simplify(regs[dst]).as_long()
        bVar13 = concrete_val < imm

    elif op == 16: # CMP ==
        concrete_val = simplify(regs[dst]).as_long()
        bVar13 = concrete_val == imm
        
    elif op == 17: # CMP REG == REG (CHECK FLAG)
        solver.add(regs[dst] == regs[src])
        bVar13 = True
        constraints_added += 1
        
    elif op == 18: next_pc = imm
    elif op == 19: 
        if bVar13: next_pc = imm
    elif op == 20: 
        if not bVar13: next_pc = imm
    
    elif op == 21: # Success
        print("[!] Reached Success State!")
        break

    pc_index = next_pc

print(f"[*] Execution finished. Constraints added: {constraints_added}")

if constraints_added > 0:
    print("[*] Solving...")
    if solver.check() == sat:
        m = solver.model()
        res = "".join([chr(m[c].as_long()) for c in flag])
        print(f"\n[+] FLAG FOUND: {res}")
    else:
        print("[-] UNSAT")
else:
    print("[-] FAILED: No constraints generated.")